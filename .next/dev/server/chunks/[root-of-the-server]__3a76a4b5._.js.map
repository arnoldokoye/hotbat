{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/arnoldokoye/hotbat/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\nimport { PrismaPg } from \"@prisma/adapter-pg\";\nimport { Pool } from \"pg\";\nimport fs from \"fs\";\nimport path from \"path\";\n\nconst connectionString = process.env.DATABASE_URL;\nif (!connectionString) {\n  throw new Error(\"DATABASE_URL is required to initialize Prisma\");\n}\n\n// Ensure a single PrismaClient/Pool instance across hot reloads in dev.\nconst globalForPrisma = globalThis as unknown as {\n  prisma?: PrismaClient;\n  pool?: Pool;\n  adapter?: PrismaPg;\n  __dbUsedInsecureSsl?: boolean;\n};\n\nconst defaultCaPath =\n  process.env.NODE_EXTRA_CA_CERTS ||\n  path.join(process.cwd(), \"prod-ca-2021.crt\");\nconst caFileExists = defaultCaPath ? fs.existsSync(defaultCaPath) : false;\nconst caBuffer = caFileExists ? fs.readFileSync(defaultCaPath) : undefined;\nconst allowInsecureEnv =\n  process.env.DB_SSL_ALLOW_INSECURE === \"1\" ||\n  process.env.DB_SSL_ALLOW_INSECURE === \"true\" ||\n  process.env.NODE_TLS_REJECT_UNAUTHORIZED === \"0\";\nconst connectionTimeoutMs =\n  Number.parseInt(process.env.DB_CONNECTION_TIMEOUT_MS ?? \"\", 10) || 5000;\n\ntype PoolInit = {\n  pool: Pool;\n  usedInsecure: boolean;\n};\n\nconst buildPool = (rejectUnauthorized: boolean): PoolInit => {\n  const ssl: { rejectUnauthorized: boolean; ca?: Buffer } = { rejectUnauthorized };\n  if (caBuffer) {\n    ssl.ca = caBuffer;\n  }\n  return {\n    pool: new Pool({\n      connectionString,\n      ssl,\n      connectionTimeoutMillis: connectionTimeoutMs,\n    }),\n    usedInsecure: !rejectUnauthorized,\n  };\n};\n\nconst isTlsError = (error: unknown) => {\n  if (!error || typeof error !== \"object\") return false;\n  const code = (error as { code?: string }).code ?? \"\";\n  const message = (error as { message?: string }).message ?? \"\";\n  const tlsCodes = [\n    \"SELF_SIGNED_CERT_IN_CHAIN\",\n    \"DEPTH_ZERO_SELF_SIGNED_CERT\",\n    \"UNABLE_TO_VERIFY_LEAF_SIGNATURE\",\n    \"ERR_TLS_CERT_ALTNAME_INVALID\",\n    \"UNABLE_TO_GET_ISSUER_CERT_LOCALLY\",\n  ];\n  return tlsCodes.includes(code) || message.toLowerCase().includes(\"certificate\");\n};\n\nconst initPool = async (): Promise<PoolInit> => {\n  const primary = buildPool(!allowInsecureEnv);\n\n  const warmupResult = await primary.pool\n    .query(\"SELECT 1\")\n    .then(() => \"ok\" as const)\n    .catch((error) => {\n      if (!allowInsecureEnv && isTlsError(error)) {\n        return \"tls-error\" as const;\n      }\n      console.warn(\n        \"Database warm-up query failed; continuing with current SSL config.\",\n        error,\n      );\n      return \"failed\" as const;\n    });\n\n  if (warmupResult === \"tls-error\") {\n    await primary.pool.end().catch(() => {});\n    console.warn(\n      \"Database TLS verification failed; retrying with rejectUnauthorized=false. \" +\n        \"Provide NODE_EXTRA_CA_CERTS with your trusted root to restore verification.\",\n    );\n    return buildPool(false);\n  }\n\n  return primary;\n};\n\nconst { pool, usedInsecure } =\n  globalForPrisma.pool && typeof globalForPrisma.__dbUsedInsecureSsl === \"boolean\"\n    ? { pool: globalForPrisma.pool, usedInsecure: globalForPrisma.__dbUsedInsecureSsl }\n    : await initPool();\n\nconst adapter = globalForPrisma.adapter ?? new PrismaPg(pool);\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    adapter,\n    log: process.env.NODE_ENV === \"development\" ? [\"warn\", \"error\"] : [\"error\"],\n  });\n\nif (process.env.NODE_ENV !== \"production\") {\n  globalForPrisma.pool = pool;\n  globalForPrisma.adapter = adapter;\n  globalForPrisma.prisma = prisma;\n  globalForPrisma.__dbUsedInsecureSsl = usedInsecure;\n}\n\nexport default prisma;\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAEA,MAAM,mBAAmB,QAAQ,GAAG,CAAC,YAAY;AACjD,IAAI,CAAC,kBAAkB;IACrB,MAAM,IAAI,MAAM;AAClB;AAEA,wEAAwE;AACxE,MAAM,kBAAkB;AAOxB,MAAM,gBACJ,QAAQ,GAAG,CAAC,mBAAmB,IAC/B,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;AAC3B,MAAM,eAAe,uCAAgB,wGAAE,CAAC,UAAU,CAAC,iBAAiB;AACpE,MAAM,WAAW,eAAe,wGAAE,CAAC,YAAY,CAAC,iBAAiB;AACjE,MAAM,mBACJ,QAAQ,GAAG,CAAC,qBAAqB,KAAK,OACtC,QAAQ,GAAG,CAAC,qBAAqB,KAAK,UACtC,QAAQ,GAAG,CAAC,4BAA4B,KAAK;AAC/C,MAAM,sBACJ,OAAO,QAAQ,CAAC,QAAQ,GAAG,CAAC,wBAAwB,IAAI,IAAI,OAAO;AAOrE,MAAM,YAAY,CAAC;IACjB,MAAM,MAAoD;QAAE;IAAmB;IAC/E,IAAI,UAAU;QACZ,IAAI,EAAE,GAAG;IACX;IACA,OAAO;QACL,MAAM,IAAI,4GAAI,CAAC;YACb;YACA;YACA,yBAAyB;QAC3B;QACA,cAAc,CAAC;IACjB;AACF;AAEA,MAAM,aAAa,CAAC;IAClB,IAAI,CAAC,SAAS,OAAO,UAAU,UAAU,OAAO;IAChD,MAAM,OAAO,AAAC,MAA4B,IAAI,IAAI;IAClD,MAAM,UAAU,AAAC,MAA+B,OAAO,IAAI;IAC3D,MAAM,WAAW;QACf;QACA;QACA;QACA;QACA;KACD;IACD,OAAO,SAAS,QAAQ,CAAC,SAAS,QAAQ,WAAW,GAAG,QAAQ,CAAC;AACnE;AAEA,MAAM,WAAW;IACf,MAAM,UAAU,UAAU,CAAC;IAE3B,MAAM,eAAe,MAAM,QAAQ,IAAI,CACpC,KAAK,CAAC,YACN,IAAI,CAAC,IAAM,MACX,KAAK,CAAC,CAAC;QACN,IAAI,CAAC,oBAAoB,WAAW,QAAQ;YAC1C,OAAO;QACT;QACA,QAAQ,IAAI,CACV,sEACA;QAEF,OAAO;IACT;IAEF,IAAI,iBAAiB,aAAa;QAChC,MAAM,QAAQ,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,KAAO;QACtC,QAAQ,IAAI,CACV,+EACE;QAEJ,OAAO,UAAU;IACnB;IAEA,OAAO;AACT;AAEA,MAAM,EAAE,IAAI,EAAE,YAAY,EAAE,GAC1B,gBAAgB,IAAI,IAAI,OAAO,gBAAgB,mBAAmB,KAAK,YACnE;IAAE,MAAM,gBAAgB,IAAI;IAAE,cAAc,gBAAgB,mBAAmB;AAAC,IAChF,MAAM;AAEZ,MAAM,UAAU,gBAAgB,OAAO,IAAI,IAAI,yKAAQ,CAAC;AAEjD,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf;IACA,KAAK,uCAAyC;QAAC;QAAQ;KAAQ,GAAG;AACpE;AAEF,wCAA2C;IACzC,gBAAgB,IAAI,GAAG;IACvB,gBAAgB,OAAO,GAAG;IAC1B,gBAAgB,MAAM,GAAG;IACzB,gBAAgB,mBAAmB,GAAG;AACxC;uCAEe"}},
    {"offset": {"line": 189, "column": 0}, "map": {"version":3,"sources":["file:///Users/arnoldokoye/hotbat/src/lib/csv/ballparks.ts"],"sourcesContent":["import fs from \"node:fs/promises\";\nimport path from \"node:path\";\n\nconst GAMELOGS_DIR = path.join(process.cwd(), \"data_sources\", \"NEW_DATA_SETS\", \"2020-25 GAMELOGS\");\nconst BALLPARKS_CSV_PATH = path.join(GAMELOGS_DIR, \"ballparks.csv\");\n\nlet cache: { mtimeMs: number; byParkId: Map<string, string> } | null = null;\n\nfunction splitCsvLine(line: string): string[] {\n  const out: string[] = [];\n  let cur = \"\";\n  let inQuotes = false;\n\n  for (let i = 0; i < line.length; i += 1) {\n    const ch = line[i];\n\n    if (ch === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        cur += '\"';\n        i += 1;\n        continue;\n      }\n      inQuotes = !inQuotes;\n      continue;\n    }\n\n    if (ch === \",\" && !inQuotes) {\n      out.push(cur);\n      cur = \"\";\n      continue;\n    }\n\n    cur += ch;\n  }\n\n  out.push(cur);\n  return out;\n}\n\nexport async function loadBallparks(): Promise<Map<string, string>> {\n  const stat = await fs.stat(BALLPARKS_CSV_PATH);\n  if (cache && cache.mtimeMs === stat.mtimeMs) return cache.byParkId;\n\n  const csvText = await fs.readFile(BALLPARKS_CSV_PATH, \"utf8\");\n  const text = csvText.replace(/^\\uFEFF/, \"\").trim();\n  const lines = text.split(/\\r?\\n/).filter(Boolean);\n  if (lines.length < 2) throw new Error(`ballparks.csv is empty: ${BALLPARKS_CSV_PATH}`);\n\n  const header = splitCsvLine(lines[0]).map((h) => h.trim().toUpperCase());\n  const idx = new Map(header.map((h, i) => [h, i]));\n\n  function cell(cols: string[], key: string): string {\n    const i = idx.get(key);\n    return i === undefined ? \"\" : (cols[i] ?? \"\").trim();\n  }\n\n  const byParkId = new Map<string, string>();\n  for (const line of lines.slice(1)) {\n    const cols = splitCsvLine(line);\n    const parkId = cell(cols, \"PARKID\");\n    const name = cell(cols, \"NAME\");\n    if (!parkId || !name) continue;\n    if (!byParkId.has(parkId)) byParkId.set(parkId, name);\n  }\n\n  cache = { mtimeMs: stat.mtimeMs, byParkId };\n  return byParkId;\n}\n\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,MAAM,eAAe,4HAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,gBAAgB,iBAAiB;AAC/E,MAAM,qBAAqB,4HAAI,CAAC,IAAI,CAAC,cAAc;AAEnD,IAAI,QAAmE;AAEvE,SAAS,aAAa,IAAY;IAChC,MAAM,MAAgB,EAAE;IACxB,IAAI,MAAM;IACV,IAAI,WAAW;IAEf,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,KAAK,EAAG;QACvC,MAAM,KAAK,IAAI,CAAC,EAAE;QAElB,IAAI,OAAO,KAAK;YACd,IAAI,YAAY,IAAI,CAAC,IAAI,EAAE,KAAK,KAAK;gBACnC,OAAO;gBACP,KAAK;gBACL;YACF;YACA,WAAW,CAAC;YACZ;QACF;QAEA,IAAI,OAAO,OAAO,CAAC,UAAU;YAC3B,IAAI,IAAI,CAAC;YACT,MAAM;YACN;QACF;QAEA,OAAO;IACT;IAEA,IAAI,IAAI,CAAC;IACT,OAAO;AACT;AAEO,eAAe;IACpB,MAAM,OAAO,MAAM,gJAAE,CAAC,IAAI,CAAC;IAC3B,IAAI,SAAS,MAAM,OAAO,KAAK,KAAK,OAAO,EAAE,OAAO,MAAM,QAAQ;IAElE,MAAM,UAAU,MAAM,gJAAE,CAAC,QAAQ,CAAC,oBAAoB;IACtD,MAAM,OAAO,QAAQ,OAAO,CAAC,WAAW,IAAI,IAAI;IAChD,MAAM,QAAQ,KAAK,KAAK,CAAC,SAAS,MAAM,CAAC;IACzC,IAAI,MAAM,MAAM,GAAG,GAAG,MAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,oBAAoB;IAErF,MAAM,SAAS,aAAa,KAAK,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI,GAAG,WAAW;IACrE,MAAM,MAAM,IAAI,IAAI,OAAO,GAAG,CAAC,CAAC,GAAG,IAAM;YAAC;YAAG;SAAE;IAE/C,SAAS,KAAK,IAAc,EAAE,GAAW;QACvC,MAAM,IAAI,IAAI,GAAG,CAAC;QAClB,OAAO,MAAM,YAAY,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,EAAE,IAAI;IACpD;IAEA,MAAM,WAAW,IAAI;IACrB,KAAK,MAAM,QAAQ,MAAM,KAAK,CAAC,GAAI;QACjC,MAAM,OAAO,aAAa;QAC1B,MAAM,SAAS,KAAK,MAAM;QAC1B,MAAM,OAAO,KAAK,MAAM;QACxB,IAAI,CAAC,UAAU,CAAC,MAAM;QACtB,IAAI,CAAC,SAAS,GAAG,CAAC,SAAS,SAAS,GAAG,CAAC,QAAQ;IAClD;IAEA,QAAQ;QAAE,SAAS,KAAK,OAAO;QAAE;IAAS;IAC1C,OAAO;AACT"}},
    {"offset": {"line": 259, "column": 0}, "map": {"version":3,"sources":["file:///Users/arnoldokoye/hotbat/src/lib/csv/csv.ts"],"sourcesContent":["import fs from \"node:fs/promises\";\n\nexport function splitCsvLine(line: string): string[] {\n  const out: string[] = [];\n  let cur = \"\";\n  let inQuotes = false;\n\n  for (let i = 0; i < line.length; i += 1) {\n    const ch = line[i];\n\n    if (ch === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        cur += '\"';\n        i += 1;\n        continue;\n      }\n      inQuotes = !inQuotes;\n      continue;\n    }\n\n    if (ch === \",\" && !inQuotes) {\n      out.push(cur);\n      cur = \"\";\n      continue;\n    }\n\n    cur += ch;\n  }\n\n  out.push(cur);\n  return out;\n}\n\nexport function parseCsvText(text: string): { header: string[]; rows: string[][] } {\n  const stripped = text.replace(/^\\uFEFF/, \"\").trim();\n  if (!stripped) return { header: [], rows: [] };\n\n  const lines = stripped.split(/\\r?\\n/).filter(Boolean);\n  if (lines.length === 0) return { header: [], rows: [] };\n\n  const header = splitCsvLine(lines[0]).map((h) => h.trim());\n  const rows = lines.slice(1).map((line) => splitCsvLine(line).map((c) => c.trim()));\n  return { header, rows };\n}\n\nexport async function readCsvFile(filePath: string): Promise<{ header: string[]; rows: string[][]; mtimeMs: number }> {\n  const stat = await fs.stat(filePath);\n  const text = await fs.readFile(filePath, \"utf8\");\n  const { header, rows } = parseCsvText(text);\n  return { header, rows, mtimeMs: stat.mtimeMs };\n}\n\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEO,SAAS,aAAa,IAAY;IACvC,MAAM,MAAgB,EAAE;IACxB,IAAI,MAAM;IACV,IAAI,WAAW;IAEf,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,KAAK,EAAG;QACvC,MAAM,KAAK,IAAI,CAAC,EAAE;QAElB,IAAI,OAAO,KAAK;YACd,IAAI,YAAY,IAAI,CAAC,IAAI,EAAE,KAAK,KAAK;gBACnC,OAAO;gBACP,KAAK;gBACL;YACF;YACA,WAAW,CAAC;YACZ;QACF;QAEA,IAAI,OAAO,OAAO,CAAC,UAAU;YAC3B,IAAI,IAAI,CAAC;YACT,MAAM;YACN;QACF;QAEA,OAAO;IACT;IAEA,IAAI,IAAI,CAAC;IACT,OAAO;AACT;AAEO,SAAS,aAAa,IAAY;IACvC,MAAM,WAAW,KAAK,OAAO,CAAC,WAAW,IAAI,IAAI;IACjD,IAAI,CAAC,UAAU,OAAO;QAAE,QAAQ,EAAE;QAAE,MAAM,EAAE;IAAC;IAE7C,MAAM,QAAQ,SAAS,KAAK,CAAC,SAAS,MAAM,CAAC;IAC7C,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO;QAAE,QAAQ,EAAE;QAAE,MAAM,EAAE;IAAC;IAEtD,MAAM,SAAS,aAAa,KAAK,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI;IACvD,MAAM,OAAO,MAAM,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,OAAS,aAAa,MAAM,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI;IAC9E,OAAO;QAAE;QAAQ;IAAK;AACxB;AAEO,eAAe,YAAY,QAAgB;IAChD,MAAM,OAAO,MAAM,gJAAE,CAAC,IAAI,CAAC;IAC3B,MAAM,OAAO,MAAM,gJAAE,CAAC,QAAQ,CAAC,UAAU;IACzC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,aAAa;IACtC,OAAO;QAAE;QAAQ;QAAM,SAAS,KAAK,OAAO;IAAC;AAC/C"}},
    {"offset": {"line": 326, "column": 0}, "map": {"version":3,"sources":["file:///Users/arnoldokoye/hotbat/src/lib/csv/dailyBatting.ts"],"sourcesContent":["import path from \"node:path\";\n\nimport { readCsvFile } from \"@/lib/csv/csv\";\n\nconst DAILY_LOGS_DIR = path.join(process.cwd(), \"data_sources\", \"NEW_DATA_SETS\", \"2020-25 DAILY LOGS\");\n\nexport type DailyBattingRow = {\n  gid: string;\n  player_id: string;\n  team: string;\n  opp: string;\n  vishome: \"h\" | \"v\" | \"\";\n  site: string;\n  date: string; // YYYYMMDD\n  b_pa: number;\n  b_ab: number;\n  b_hr: number;\n  b_d: number;\n  b_t: number;\n  b_rbi: number;\n  b_w: number;\n  b_k: number;\n};\n\nlet cache:\n  | {\n      season: number;\n      mtimeMs: number;\n      rows: DailyBattingRow[];\n    }\n  | null = null;\n\nfunction asInt(value: string): number {\n  const n = Number.parseInt(value, 10);\n  return Number.isFinite(n) ? n : 0;\n}\n\nexport async function loadDailyBatting(season: number): Promise<DailyBattingRow[]> {\n  const filePath = path.join(DAILY_LOGS_DIR, `${season}DAILY_LOGScsvs`, `${season}batting.csv`);\n\n  const { header, rows, mtimeMs } = await readCsvFile(filePath);\n  if (cache && cache.season === season && cache.mtimeMs === mtimeMs) return cache.rows;\n\n  const idx = new Map(header.map((h, i) => [h, i] as const));\n  const cell = (cols: string[], key: string) => {\n    const i = idx.get(key);\n    return i === undefined ? \"\" : (cols[i] ?? \"\");\n  };\n\n  const parsed: DailyBattingRow[] = [];\n  for (const cols of rows) {\n    const stattype = cell(cols, \"stattype\").toLowerCase();\n    if (stattype && stattype !== \"value\") continue;\n\n    const gid = cell(cols, \"gid\");\n    const player_id = cell(cols, \"id\");\n    const team = cell(cols, \"team\");\n    const opp = cell(cols, \"opp\");\n    const vishome = cell(cols, \"vishome\") as DailyBattingRow[\"vishome\"];\n    const site = cell(cols, \"site\");\n    const date = cell(cols, \"date\");\n\n    if (!gid || !player_id || !team || !date) continue;\n\n    parsed.push({\n      gid,\n      player_id,\n      team,\n      opp,\n      vishome: vishome === \"h\" || vishome === \"v\" ? vishome : \"\",\n      site,\n      date,\n      b_pa: asInt(cell(cols, \"b_pa\")),\n      b_ab: asInt(cell(cols, \"b_ab\")),\n      b_hr: asInt(cell(cols, \"b_hr\")),\n      b_d: asInt(cell(cols, \"b_d\")),\n      b_t: asInt(cell(cols, \"b_t\")),\n      b_rbi: asInt(cell(cols, \"b_rbi\")),\n      b_w: asInt(cell(cols, \"b_w\")),\n      b_k: asInt(cell(cols, \"b_k\")),\n    });\n  }\n\n  // Deterministic ordering.\n  parsed.sort((a, b) => {\n    if (a.date !== b.date) return a.date.localeCompare(b.date);\n    if (a.gid !== b.gid) return a.gid.localeCompare(b.gid);\n    if (a.player_id !== b.player_id) return a.player_id.localeCompare(b.player_id);\n    return a.team.localeCompare(b.team);\n  });\n\n  cache = { season, mtimeMs, rows: parsed };\n  return parsed;\n}\n\n"],"names":[],"mappings":";;;;AAAA;AAEA;;;AAEA,MAAM,iBAAiB,4HAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,gBAAgB,iBAAiB;AAoBjF,IAAI,QAMO;AAEX,SAAS,MAAM,KAAa;IAC1B,MAAM,IAAI,OAAO,QAAQ,CAAC,OAAO;IACjC,OAAO,OAAO,QAAQ,CAAC,KAAK,IAAI;AAClC;AAEO,eAAe,iBAAiB,MAAc;IACnD,MAAM,WAAW,4HAAI,CAAC,IAAI,CAAC,gBAAgB,GAAG,OAAO,cAAc,CAAC,EAAE,GAAG,OAAO,WAAW,CAAC;IAE5F,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,yIAAW,EAAC;IACpD,IAAI,SAAS,MAAM,MAAM,KAAK,UAAU,MAAM,OAAO,KAAK,SAAS,OAAO,MAAM,IAAI;IAEpF,MAAM,MAAM,IAAI,IAAI,OAAO,GAAG,CAAC,CAAC,GAAG,IAAM;YAAC;YAAG;SAAE;IAC/C,MAAM,OAAO,CAAC,MAAgB;QAC5B,MAAM,IAAI,IAAI,GAAG,CAAC;QAClB,OAAO,MAAM,YAAY,KAAM,IAAI,CAAC,EAAE,IAAI;IAC5C;IAEA,MAAM,SAA4B,EAAE;IACpC,KAAK,MAAM,QAAQ,KAAM;QACvB,MAAM,WAAW,KAAK,MAAM,YAAY,WAAW;QACnD,IAAI,YAAY,aAAa,SAAS;QAEtC,MAAM,MAAM,KAAK,MAAM;QACvB,MAAM,YAAY,KAAK,MAAM;QAC7B,MAAM,OAAO,KAAK,MAAM;QACxB,MAAM,MAAM,KAAK,MAAM;QACvB,MAAM,UAAU,KAAK,MAAM;QAC3B,MAAM,OAAO,KAAK,MAAM;QACxB,MAAM,OAAO,KAAK,MAAM;QAExB,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,QAAQ,CAAC,MAAM;QAE1C,OAAO,IAAI,CAAC;YACV;YACA;YACA;YACA;YACA,SAAS,YAAY,OAAO,YAAY,MAAM,UAAU;YACxD;YACA;YACA,MAAM,MAAM,KAAK,MAAM;YACvB,MAAM,MAAM,KAAK,MAAM;YACvB,MAAM,MAAM,KAAK,MAAM;YACvB,KAAK,MAAM,KAAK,MAAM;YACtB,KAAK,MAAM,KAAK,MAAM;YACtB,OAAO,MAAM,KAAK,MAAM;YACxB,KAAK,MAAM,KAAK,MAAM;YACtB,KAAK,MAAM,KAAK,MAAM;QACxB;IACF;IAEA,0BAA0B;IAC1B,OAAO,IAAI,CAAC,CAAC,GAAG;QACd,IAAI,EAAE,IAAI,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,aAAa,CAAC,EAAE,IAAI;QACzD,IAAI,EAAE,GAAG,KAAK,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,CAAC,aAAa,CAAC,EAAE,GAAG;QACrD,IAAI,EAAE,SAAS,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,SAAS,CAAC,aAAa,CAAC,EAAE,SAAS;QAC7E,OAAO,EAAE,IAAI,CAAC,aAAa,CAAC,EAAE,IAAI;IACpC;IAEA,QAAQ;QAAE;QAAQ;QAAS,MAAM;IAAO;IACxC,OAAO;AACT"}},
    {"offset": {"line": 400, "column": 0}, "map": {"version":3,"sources":["file:///Users/arnoldokoye/hotbat/src/lib/csv/dailyPitching.ts"],"sourcesContent":["import path from \"node:path\";\n\nimport { readCsvFile } from \"@/lib/csv/csv\";\n\nconst DAILY_LOGS_DIR = path.join(process.cwd(), \"data_sources\", \"NEW_DATA_SETS\", \"2020-25 DAILY LOGS\");\n\nexport type DailyPitchingRow = {\n  gid: string;\n  pitcher_id: string;\n  team: string;\n  opp: string;\n  vishome: \"h\" | \"v\" | \"\";\n  date: string; // YYYYMMDD\n  p_seq: number;\n  p_ipouts: number;\n  p_er: number;\n  p_hr: number;\n};\n\nexport type StartersByGame = Map<string, { home?: string; away?: string }>;\n\nlet cache:\n  | {\n      season: number;\n      mtimeMs: number;\n      startersByGame: StartersByGame;\n    }\n  | null = null;\n\nfunction asInt(value: string): number {\n  const n = Number.parseInt(value, 10);\n  return Number.isFinite(n) ? n : 0;\n}\n\nexport async function loadDailyPitchingStartersByGame(season: number): Promise<StartersByGame> {\n  const filePath = path.join(DAILY_LOGS_DIR, `${season}DAILY_LOGScsvs`, `${season}pitching.csv`);\n  const { header, rows, mtimeMs } = await readCsvFile(filePath);\n  if (cache && cache.season === season && cache.mtimeMs === mtimeMs) return cache.startersByGame;\n\n  const idx = new Map(header.map((h, i) => [h, i] as const));\n  const cell = (cols: string[], key: string) => {\n    const i = idx.get(key);\n    return i === undefined ? \"\" : (cols[i] ?? \"\");\n  };\n\n  const startersByGame: StartersByGame = new Map();\n\n  for (const cols of rows) {\n    const stattype = cell(cols, \"stattype\").toLowerCase();\n    if (stattype && stattype !== \"value\") continue;\n\n    const pSeq = asInt(cell(cols, \"p_seq\"));\n    if (pSeq !== 1) continue;\n\n    const gid = cell(cols, \"gid\");\n    const pitcher_id = cell(cols, \"id\");\n    const vishome = cell(cols, \"vishome\");\n    if (!gid || !pitcher_id) continue;\n\n    const entry = startersByGame.get(gid) ?? {};\n    if (vishome === \"h\") entry.home = pitcher_id;\n    if (vishome === \"v\") entry.away = pitcher_id;\n    startersByGame.set(gid, entry);\n  }\n\n  cache = { season, mtimeMs, startersByGame };\n  return startersByGame;\n}\n\n"],"names":[],"mappings":";;;;AAAA;AAEA;;;AAEA,MAAM,iBAAiB,4HAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,gBAAgB,iBAAiB;AAiBjF,IAAI,QAMO;AAEX,SAAS,MAAM,KAAa;IAC1B,MAAM,IAAI,OAAO,QAAQ,CAAC,OAAO;IACjC,OAAO,OAAO,QAAQ,CAAC,KAAK,IAAI;AAClC;AAEO,eAAe,gCAAgC,MAAc;IAClE,MAAM,WAAW,4HAAI,CAAC,IAAI,CAAC,gBAAgB,GAAG,OAAO,cAAc,CAAC,EAAE,GAAG,OAAO,YAAY,CAAC;IAC7F,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,yIAAW,EAAC;IACpD,IAAI,SAAS,MAAM,MAAM,KAAK,UAAU,MAAM,OAAO,KAAK,SAAS,OAAO,MAAM,cAAc;IAE9F,MAAM,MAAM,IAAI,IAAI,OAAO,GAAG,CAAC,CAAC,GAAG,IAAM;YAAC;YAAG;SAAE;IAC/C,MAAM,OAAO,CAAC,MAAgB;QAC5B,MAAM,IAAI,IAAI,GAAG,CAAC;QAClB,OAAO,MAAM,YAAY,KAAM,IAAI,CAAC,EAAE,IAAI;IAC5C;IAEA,MAAM,iBAAiC,IAAI;IAE3C,KAAK,MAAM,QAAQ,KAAM;QACvB,MAAM,WAAW,KAAK,MAAM,YAAY,WAAW;QACnD,IAAI,YAAY,aAAa,SAAS;QAEtC,MAAM,OAAO,MAAM,KAAK,MAAM;QAC9B,IAAI,SAAS,GAAG;QAEhB,MAAM,MAAM,KAAK,MAAM;QACvB,MAAM,aAAa,KAAK,MAAM;QAC9B,MAAM,UAAU,KAAK,MAAM;QAC3B,IAAI,CAAC,OAAO,CAAC,YAAY;QAEzB,MAAM,QAAQ,eAAe,GAAG,CAAC,QAAQ,CAAC;QAC1C,IAAI,YAAY,KAAK,MAAM,IAAI,GAAG;QAClC,IAAI,YAAY,KAAK,MAAM,IAAI,GAAG;QAClC,eAAe,GAAG,CAAC,KAAK;IAC1B;IAEA,QAAQ;QAAE;QAAQ;QAAS;IAAe;IAC1C,OAAO;AACT"}},
    {"offset": {"line": 452, "column": 0}, "map": {"version":3,"sources":["file:///Users/arnoldokoye/hotbat/src/lib/csv/playerRegistry.ts"],"sourcesContent":["import fs from \"node:fs/promises\";\nimport path from \"node:path\";\n\nimport type { Handedness, PlayerSummary, ThrowHand } from \"@/lib/backend/DataBackend\";\n\nconst PLAYER_REGISTRY_CSV_PATH = path.join(process.cwd(), \"scripts\", \"ml\", \"data\", \"player_registry.csv\");\nconst BIOFILE_CSV_PATH = path.join(\n  process.cwd(),\n  \"data_sources\",\n  \"NEW_DATA_SETS\",\n  \"2020-25 GAMELOGS\",\n  \"biofile (1)\",\n  \"biofile.csv\",\n);\n\ntype PlayerRegistryRow = {\n  player_id: string;\n  player_name: string;\n  first_name: string;\n  last_name: string;\n};\n\nlet cache:\n  | {\n      registryMtimeMs: number;\n      bioMtimeMs: number | null;\n      players: PlayerSummary[];\n    }\n  | null = null;\n\nfunction splitCsvLine(line: string): string[] {\n  const out: string[] = [];\n  let cur = \"\";\n  let inQuotes = false;\n\n  for (let i = 0; i < line.length; i += 1) {\n    const ch = line[i];\n\n    if (ch === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        cur += '\"';\n        i += 1;\n        continue;\n      }\n      inQuotes = !inQuotes;\n      continue;\n    }\n\n    if (ch === \",\" && !inQuotes) {\n      out.push(cur);\n      cur = \"\";\n      continue;\n    }\n\n    cur += ch;\n  }\n\n  out.push(cur);\n  return out;\n}\n\nfunction normalizeBats(value: string): Handedness | null {\n  const v = value.trim().toUpperCase();\n  if (v === \"L\" || v === \"R\" || v === \"B\") return v;\n  return null;\n}\n\nfunction normalizeThrows(value: string): ThrowHand | null {\n  const v = value.trim().toUpperCase();\n  if (v === \"L\" || v === \"R\") return v;\n  return null;\n}\n\nfunction parseYearFromMmDdYyyy(value: string): number | null {\n  const v = value.trim();\n  const m = /^\\d{2}\\/\\d{2}\\/(\\d{4})$/.exec(v);\n  if (!m) return null;\n  const year = Number.parseInt(m[1], 10);\n  return Number.isFinite(year) ? year : null;\n}\n\nasync function loadPlayerRegistryRows(): Promise<PlayerRegistryRow[]> {\n  const csvText = await fs.readFile(PLAYER_REGISTRY_CSV_PATH, \"utf8\");\n  const text = csvText.replace(/^\\uFEFF/, \"\").trim();\n  if (!text) return [];\n  const lines = text.split(/\\r?\\n/).filter(Boolean);\n  if (lines.length < 2) return [];\n\n  const header = splitCsvLine(lines[0]).map((h) => h.trim());\n  const idx = new Map(header.map((h, i) => [h, i]));\n\n  const idIdx = idx.get(\"player_id\");\n  const firstIdx = idx.get(\"first_name\");\n  const lastIdx = idx.get(\"last_name\");\n  const nameIdx = idx.get(\"full_name\");\n  if (idIdx === undefined || nameIdx === undefined || firstIdx === undefined || lastIdx === undefined) {\n    return [];\n  }\n\n  const rows: PlayerRegistryRow[] = [];\n  for (const line of lines.slice(1)) {\n    const cols = splitCsvLine(line);\n    const player_id = (cols[idIdx] ?? \"\").trim();\n    const first_name = (cols[firstIdx] ?? \"\").trim();\n    const last_name = (cols[lastIdx] ?? \"\").trim();\n    const player_name = (cols[nameIdx] ?? \"\").trim();\n    if (!player_id || !player_name || !first_name || !last_name) continue;\n    rows.push({ player_id, player_name, first_name, last_name });\n  }\n  return rows;\n}\n\nasync function loadBioHands(): Promise<\n  Map<\n    string,\n    {\n      bats: Handedness | null;\n      throws: ThrowHand | null;\n      first_season: number | null;\n      last_season: number | null;\n    }\n  >\n> {\n  const byId = new Map<\n    string,\n    {\n      bats: Handedness | null;\n      throws: ThrowHand | null;\n      first_season: number | null;\n      last_season: number | null;\n    }\n  >();\n\n  const csvText = await fs.readFile(BIOFILE_CSV_PATH, \"utf8\");\n  const text = csvText.replace(/^\\uFEFF/, \"\").trim();\n  if (!text) return byId;\n\n  const lines = text.split(/\\r?\\n/).filter(Boolean);\n  if (lines.length < 2) return byId;\n\n  const header = splitCsvLine(lines[0]).map((h) => h.trim().toUpperCase());\n  const idx = new Map(header.map((h, i) => [h, i]));\n\n  function cell(cols: string[], key: string): string {\n    const i = idx.get(key);\n    return i === undefined ? \"\" : (cols[i] ?? \"\").trim();\n  }\n\n  for (const line of lines.slice(1)) {\n    const cols = splitCsvLine(line);\n    const playerId = cell(cols, \"PLAYERID\");\n    if (!playerId) continue;\n    if (byId.has(playerId)) continue;\n\n    const bats = normalizeBats(cell(cols, \"BATS\"));\n    const throws = normalizeThrows(cell(cols, \"THROWS\"));\n    const first_season = parseYearFromMmDdYyyy(cell(cols, \"PLAY.DEBUT\"));\n    const last_season = parseYearFromMmDdYyyy(cell(cols, \"PLAY.LASTGAME\"));\n    byId.set(playerId, { bats, throws, first_season, last_season });\n  }\n\n  return byId;\n}\n\nexport async function loadPlayerRegistry(): Promise<PlayerSummary[]> {\n  const registryStat = await fs.stat(PLAYER_REGISTRY_CSV_PATH);\n\n  let bioStat: { mtimeMs: number } | null = null;\n  try {\n    bioStat = await fs.stat(BIOFILE_CSV_PATH);\n  } catch {\n    bioStat = null;\n  }\n\n  if (\n    cache &&\n    cache.registryMtimeMs === registryStat.mtimeMs &&\n    cache.bioMtimeMs === (bioStat ? bioStat.mtimeMs : null)\n  ) {\n    return cache.players;\n  }\n\n  const registryRows = await loadPlayerRegistryRows();\n  if (!registryRows.length) {\n    cache = { registryMtimeMs: registryStat.mtimeMs, bioMtimeMs: bioStat?.mtimeMs ?? null, players: [] };\n    return [];\n  }\n\n  const bioById = bioStat ? await loadBioHands() : new Map();\n\n  const players: PlayerSummary[] = registryRows.map((r) => {\n    const bio = bioById.get(r.player_id);\n    return {\n      player_id: r.player_id,\n      player_name: r.player_name,\n      first_name: r.first_name,\n      last_name: r.last_name,\n      bats: bio?.bats ?? null,\n      throws: bio?.throws ?? null,\n      first_season: bio?.first_season ?? null,\n      last_season: bio?.last_season ?? null,\n    };\n  });\n\n  // Deterministic ordering.\n  players.sort((a, b) => {\n    if (a.player_name !== b.player_name) return a.player_name.localeCompare(b.player_name);\n    return a.player_id.localeCompare(b.player_id);\n  });\n\n  cache = {\n    registryMtimeMs: registryStat.mtimeMs,\n    bioMtimeMs: bioStat?.mtimeMs ?? null,\n    players,\n  };\n\n  return players;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 624, "column": 0}, "map": {"version":3,"sources":["file:///Users/arnoldokoye/hotbat/src/lib/csv/teams.ts"],"sourcesContent":["import fs from \"node:fs/promises\";\nimport path from \"node:path\";\n\nimport type { TeamSummary } from \"@/lib/backend/DataBackend\";\n\nconst GAMELOGS_DIR = path.join(process.cwd(), \"data_sources\", \"NEW_DATA_SETS\", \"2020-25 GAMELOGS\");\nconst TEAMS_CSV_PATH = path.join(GAMELOGS_DIR, \"teams.csv\");\n\nlet cache:\n  | {\n      mtimeMs: number;\n      teams: TeamSummary[];\n    }\n  | null = null;\n\nfunction splitCsvLine(line: string): string[] {\n  const out: string[] = [];\n  let cur = \"\";\n  let inQuotes = false;\n\n  for (let i = 0; i < line.length; i += 1) {\n    const ch = line[i];\n\n    if (ch === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        cur += '\"';\n        i += 1;\n        continue;\n      }\n      inQuotes = !inQuotes;\n      continue;\n    }\n\n    if (ch === \",\" && !inQuotes) {\n      out.push(cur);\n      cur = \"\";\n      continue;\n    }\n\n    cur += ch;\n  }\n\n  out.push(cur);\n  return out;\n}\n\nfunction parseIntSafe(value: string): number | null {\n  const v = value.trim();\n  if (!v) return null;\n  const n = Number.parseInt(v, 10);\n  return Number.isFinite(n) ? n : null;\n}\n\nexport async function loadTeams(options?: {\n  minSeason?: number;\n  maxSeason?: number;\n  leagues?: string[];\n}): Promise<TeamSummary[]> {\n  const stat = await fs.stat(TEAMS_CSV_PATH);\n  if (cache && cache.mtimeMs === stat.mtimeMs) return cache.teams;\n\n  const csvText = await fs.readFile(TEAMS_CSV_PATH, \"utf8\");\n  const text = csvText.replace(/^\\uFEFF/, \"\").trim();\n  if (!text) {\n    cache = { mtimeMs: stat.mtimeMs, teams: [] };\n    return [];\n  }\n\n  const lines = text.split(/\\r?\\n/).filter(Boolean);\n  if (lines.length < 2) {\n    cache = { mtimeMs: stat.mtimeMs, teams: [] };\n    return [];\n  }\n\n  const header = splitCsvLine(lines[0]).map((h) => h.trim().toUpperCase());\n  const idx = new Map(header.map((h, i) => [h, i]));\n\n  function cell(cols: string[], key: string): string {\n    const i = idx.get(key);\n    return i === undefined ? \"\" : (cols[i] ?? \"\").trim();\n  }\n\n  const minSeason = options?.minSeason ?? 2020;\n  const maxSeason = options?.maxSeason ?? 2025;\n  const leagues =\n    options?.leagues?.map((l) => l.trim().toUpperCase()).filter(Boolean) ?? [\"AL\", \"NL\"];\n\n  type Candidate = { first: number; last: number; league: string | null; name: string };\n  const bestByTeam = new Map<string, Candidate>();\n\n  for (const line of lines.slice(1)) {\n    const cols = splitCsvLine(line);\n    const team_id = cell(cols, \"TEAM\");\n    const league = cell(cols, \"LEAGUE\").toUpperCase();\n    const city = cell(cols, \"CITY\");\n    const nickname = cell(cols, \"NICKNAME\");\n    const first = parseIntSafe(cell(cols, \"FIRST\")) ?? 0;\n    const last = parseIntSafe(cell(cols, \"LAST\")) ?? 9999;\n    if (!team_id || !city || !nickname) continue;\n    if (leagues.length && league && !leagues.includes(league)) continue;\n    if (last < minSeason || first > maxSeason) continue;\n\n    const name = `${city} ${nickname}`;\n    const cand: Candidate = { first, last, league: league || null, name };\n    const existing = bestByTeam.get(team_id);\n    if (!existing) {\n      bestByTeam.set(team_id, cand);\n      continue;\n    }\n    // Prefer the most recent era (highest FIRST), then lexicographic name for determinism.\n    if (cand.first > existing.first) {\n      bestByTeam.set(team_id, cand);\n    } else if (cand.first === existing.first && cand.name < existing.name) {\n      bestByTeam.set(team_id, cand);\n    }\n  }\n\n  const teams: TeamSummary[] = Array.from(bestByTeam.entries()).map(([team_id, cand]) => ({\n    team_id,\n    team_name: cand.name,\n    league: cand.league,\n  }));\n\n  teams.sort((a, b) => {\n    if (a.team_name !== b.team_name) return a.team_name.localeCompare(b.team_name);\n    return a.team_id.localeCompare(b.team_id);\n  });\n\n  cache = { mtimeMs: stat.mtimeMs, teams };\n  return teams;\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 753, "column": 0}, "map": {"version":3,"sources":["file:///Users/arnoldokoye/hotbat/src/app/api/player-dashboard/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { prisma } from \"@/lib/prisma\";\nimport { loadBallparks } from \"@/lib/csv/ballparks\";\nimport { loadDailyBatting } from \"@/lib/csv/dailyBatting\";\nimport { loadDailyPitchingStartersByGame } from \"@/lib/csv/dailyPitching\";\nimport { loadPlayerRegistry } from \"@/lib/csv/playerRegistry\";\nimport { loadTeams } from \"@/lib/csv/teams\";\n\ntype PlayerDashboardResponse = {\n  parkProfile?: {\n    parkName: string;\n    hrAtPark: number;\n    hrPerPaAtPark: number;\n    parkHrFactor?: number | null;\n  }[];\n  baseline?: {\n    hrProb?: number;\n    expectedHr?: number;\n    seasonHr?: number;\n    seasonPa?: number;\n    notes?: string;\n  };\n  playerInfo: {\n    id: number;\n    firstName: string;\n    lastName: string;\n    bats: string;\n    position: string;\n    team: {\n      id: number;\n      name: string;\n      abbrev: string;\n      league?: string;\n      division?: string;\n      logoUrl?: string;\n    };\n  };\n  keyMetrics: {\n    label: string;\n    value: number | null;\n  }[];\n  splits: Record<\n    string,\n    {\n      season: number;\n      gamesPlayed: number;\n      hr: number;\n      xHr: number | null;\n      hrPerPa: number | null;\n      barrelRate: number | null;\n      avgEv: number | null;\n      iso: number | null;\n      hardHitRate: number | null;\n    }\n  >;\n  hrTimeSeries: {\n    date: string;\n    gameId: number;\n    hr: number;\n    xHr: number | null;\n    avgEv: number | null;\n    opponent: string;\n    park: string;\n  }[];\n  recentGames: {\n    gameId: number;\n    date: string;\n    opponent: string;\n    park: string;\n    hr: number;\n    xHr: number | null;\n    avgEv: number | null;\n  }[];\n    upcomingGames: unknown[];\n};\n\nconst logoPath = (abbrev?: string | null) => {\n  return abbrev\n    ? `/team-logos/${abbrev.toLowerCase()}.svg`\n    : \"/team-logos/default.svg\";\n};\n\nconst logoFromRetrosheetTeam = (teamId: string) => {\n  const id = teamId.trim().toUpperCase();\n  if (id === \"NYA\") return logoPath(\"nyy\");\n  if (id === \"BOS\") return logoPath(\"bos\");\n  return logoPath(null);\n};\n\nfunction yyyymmddToIsoDate(value: string): string | null {\n  const v = value.trim();\n  if (!/^\\d{8}$/.test(v)) return null;\n  return `${v.slice(0, 4)}-${v.slice(4, 6)}-${v.slice(6, 8)}`;\n}\n\nfunction isoDateToTimestamp(value: string): string {\n  return `${value}T00:00:00.000Z`;\n}\n\nfunction hash32FNV1a(input: string): number {\n  let hash = 0x811c9dc5;\n  for (let i = 0; i < input.length; i += 1) {\n    hash ^= input.charCodeAt(i);\n    hash = Math.imul(hash, 0x01000193);\n  }\n  return hash >>> 0;\n}\n\nfunction safeDiv(numer: number, denom: number): number | null {\n  if (!Number.isFinite(numer) || !Number.isFinite(denom) || denom <= 0) return null;\n  return numer / denom;\n}\n\nasync function loadPlayerDashboardFromCsv(args: {\n  playerId: string;\n  season: number;\n  splitKey: string;\n}): Promise<PlayerDashboardResponse | null> {\n  const { playerId, season, splitKey: _splitKey } = args;\n  void _splitKey;\n\n  const [battingRows, startersByGame, players, teams, parks] = await Promise.all([\n    loadDailyBatting(season),\n    loadDailyPitchingStartersByGame(season),\n    loadPlayerRegistry(),\n    loadTeams().catch(() => []),\n    loadBallparks().catch(() => new Map<string, string>()),\n  ]);\n\n  const playerById = new Map(players.map((p) => [p.player_id, p] as const));\n  const teamNameById = new Map(teams.map((t) => [t.team_id, t.team_name] as const));\n\n  const playerMeta = playerById.get(playerId);\n  if (!playerMeta) return null;\n\n  const playerBatting = battingRows.filter((r) => r.player_id === playerId);\n\n  type GameAgg = {\n    gid: string;\n    date: string; // ISO YYYY-MM-DD\n    team: string;\n    opp: string;\n    vishome: \"h\" | \"v\" | \"\";\n    site: string;\n    pa: number;\n    ab: number;\n    hr: number;\n    doubles: number;\n    triples: number;\n    rbi: number;\n    bb: number;\n    k: number;\n    opposingStarterId: string | null;\n    opposingStarterThrows: \"L\" | \"R\" | null;\n  };\n\n  const gameAggByGid = new Map<string, GameAgg>();\n\n  for (const row of playerBatting) {\n    const dateIso = yyyymmddToIsoDate(row.date);\n    if (!dateIso) continue;\n\n    const existing = gameAggByGid.get(row.gid);\n    if (existing) {\n      existing.pa += row.b_pa;\n      existing.ab += row.b_ab;\n      existing.hr += row.b_hr;\n      existing.doubles += row.b_d;\n      existing.triples += row.b_t;\n      existing.rbi += row.b_rbi;\n      existing.bb += row.b_w;\n      existing.k += row.b_k;\n      continue;\n    }\n\n    const starters = startersByGame.get(row.gid);\n    const opposingStarterId =\n      row.vishome === \"h\" ? starters?.away ?? null : row.vishome === \"v\" ? starters?.home ?? null : null;\n    const opposingPitcher = opposingStarterId ? playerById.get(opposingStarterId) : undefined;\n    const opposingStarterThrows =\n      opposingPitcher?.throws === \"L\" || opposingPitcher?.throws === \"R\" ? opposingPitcher.throws : null;\n\n    gameAggByGid.set(row.gid, {\n      gid: row.gid,\n      date: dateIso,\n      team: row.team,\n      opp: row.opp,\n      vishome: row.vishome,\n      site: row.site,\n      pa: row.b_pa,\n      ab: row.b_ab,\n      hr: row.b_hr,\n      doubles: row.b_d,\n      triples: row.b_t,\n      rbi: row.b_rbi,\n      bb: row.b_w,\n      k: row.b_k,\n      opposingStarterId,\n      opposingStarterThrows,\n    });\n  }\n\n  const games: GameAgg[] = Array.from(gameAggByGid.values());\n\n  // Deterministic ordering.\n  games.sort((a, b) => {\n    if (a.date !== b.date) return a.date.localeCompare(b.date);\n    return a.gid.localeCompare(b.gid);\n  });\n\n  const latestGame = games.length ? games[games.length - 1] : null;\n  const teamId = latestGame?.team ?? \"\";\n  const teamName = teamNameById.get(teamId) ?? teamId;\n\n  const firstName = playerMeta.first_name ?? playerMeta.player_name.split(\" \")[0] ?? \"\";\n  const lastName = playerMeta.last_name ?? playerMeta.player_name.split(\" \").slice(1).join(\" \") ?? \"\";\n  const bats = playerMeta.bats ?? \"R\";\n\n  const totals = games.reduce(\n    (acc, g) => {\n      acc.hr += g.hr;\n      acc.pa += g.pa;\n      acc.ab += g.ab;\n      acc.doubles += g.doubles;\n      acc.triples += g.triples;\n      return acc;\n    },\n    { hr: 0, pa: 0, ab: 0, doubles: 0, triples: 0 },\n  );\n\n  const hrPerPa = safeDiv(totals.hr, totals.pa);\n  const iso = safeDiv(totals.doubles + 2 * totals.triples + 3 * totals.hr, totals.ab);\n\n  const seasonHr = totals.hr;\n  const seasonPa = totals.pa;\n  const hrProb = safeDiv(seasonHr, seasonPa) ?? 0;\n  const projectedPa = 4.0;\n  const expectedHr = hrProb * projectedPa;\n\n  const computeSplit = (filter: (g: GameAgg) => boolean) => {\n    const subset = games.filter(filter);\n    const sum = subset.reduce(\n      (acc, g) => {\n        acc.hr += g.hr;\n        acc.pa += g.pa;\n        acc.ab += g.ab;\n        acc.doubles += g.doubles;\n        acc.triples += g.triples;\n        return acc;\n      },\n      { hr: 0, pa: 0, ab: 0, doubles: 0, triples: 0 },\n    );\n    const gamesPlayed = subset.length;\n    return {\n      season,\n      gamesPlayed,\n      hr: sum.hr,\n      xHr: null as number | null,\n      hrPerPa: safeDiv(sum.hr, sum.pa),\n      barrelRate: null as number | null,\n      avgEv: null as number | null,\n      iso: safeDiv(sum.doubles + 2 * sum.triples + 3 * sum.hr, sum.ab),\n      hardHitRate: null as number | null,\n    };\n  };\n\n  const splits: PlayerDashboardResponse[\"splits\"] = {\n    overall: computeSplit(() => true),\n    home: computeSplit((g) => g.vishome === \"h\"),\n    away: computeSplit((g) => g.vishome === \"v\"),\n    lhp: computeSplit((g) => g.opposingStarterThrows === \"L\"),\n    rhp: computeSplit((g) => g.opposingStarterThrows === \"R\"),\n  };\n\n  // Monthly splits (YYYY-MM).\n  for (const g of games) {\n    const monthKey = `month:${g.date.slice(0, 7)}`;\n    if (!splits[monthKey]) {\n      splits[monthKey] = computeSplit((x) => x.date.slice(0, 7) === g.date.slice(0, 7));\n    }\n  }\n\n  const keyMetrics = [\n    { label: \"HR\", value: seasonHr },\n    { label: \"xHR\", value: null },\n    { label: \"HR/PA\", value: hrPerPa },\n    { label: \"Barrel%\", value: null },\n    { label: \"Avg EV\", value: null },\n    { label: \"ISO\", value: iso },\n    { label: \"HardHit%\", value: null },\n  ];\n\n  const gamesDesc = [...games].sort((a, b) => {\n    if (a.date !== b.date) return b.date.localeCompare(a.date);\n    return b.gid.localeCompare(a.gid);\n  });\n\n  const latest10 = gamesDesc.slice(0, 10);\n  const hrTimeSeries = [...latest10]\n    .reverse()\n    .map((g) => ({\n      date: isoDateToTimestamp(g.date),\n      gameId: hash32FNV1a(g.gid),\n      hr: g.hr,\n      xHr: null,\n      avgEv: null,\n      opponent: teamNameById.get(g.opp) ?? g.opp ?? \"Opponent\",\n      park: parks.get(g.site) ?? g.site ?? \"Park\",\n    }));\n\n  const recentGames = gamesDesc.slice(0, 5).map((g) => ({\n    gameId: hash32FNV1a(g.gid),\n    date: isoDateToTimestamp(g.date),\n    opponent: teamNameById.get(g.opp) ?? g.opp ?? \"Opponent\",\n    park: parks.get(g.site) ?? g.site ?? \"Park\",\n    hr: g.hr,\n    xHr: null,\n    avgEv: null,\n  }));\n\n  const parkAgg = games.reduce<Record<string, { hr: number; pa: number }>>((acc, g) => {\n    const parkName = parks.get(g.site) ?? g.site ?? \"Unknown Park\";\n    acc[parkName] ??= { hr: 0, pa: 0 };\n    acc[parkName].hr += g.hr;\n    acc[parkName].pa += g.pa;\n    return acc;\n  }, {});\n\n  const parkProfile = Object.entries(parkAgg).map(([parkName, agg]) => ({\n    parkName,\n    hrAtPark: agg.hr,\n    hrPerPaAtPark: agg.pa > 0 ? agg.hr / agg.pa : 0,\n    parkHrFactor: null,\n  }));\n\n  return {\n    playerInfo: {\n      id: 0,\n      firstName,\n      lastName,\n      bats,\n      position: \"—\",\n      team: {\n        id: 0,\n        name: teamName,\n        abbrev: teamId,\n        league: \"\",\n        division: \"\",\n        logoUrl: logoFromRetrosheetTeam(teamId),\n      },\n    },\n    keyMetrics,\n    splits,\n    hrTimeSeries,\n    recentGames,\n    upcomingGames: [],\n    parkProfile,\n    baseline: {\n      hrProb,\n      expectedHr,\n      seasonHr,\n      seasonPa,\n      notes:\n        \"Baseline: HR probability = season HR / season PA; Expected HR = HR probability × 4.0 PA window (deterministic).\",\n    },\n  };\n}\n\nexport async function GET(req: NextRequest) {\n  try {\n    const { searchParams } = req.nextUrl;\n    const playerIdParam = searchParams.get(\"playerId\");\n    const playerIdAlt = searchParams.get(\"player_id\");\n    const seasonParam = searchParams.get(\"season\");\n    const splitParam = searchParams.get(\"split\") ?? \"overall\";\n\n    const season = seasonParam ? Number(seasonParam) : 2024;\n    const seasonValue = Number.isNaN(season) ? 2024 : season;\n\n    const mode = (process.env.HOTBAT_BACKEND ?? \"auto\").toLowerCase();\n    const rawPlayerId = (playerIdAlt ?? playerIdParam ?? \"\").trim();\n\n    if (!rawPlayerId) {\n      return NextResponse.json(\n        { error: \"playerId query param is required\" },\n        { status: 400 },\n      );\n    }\n\n    if (mode === \"csv\" || (playerIdAlt && mode !== \"db\")) {\n      const csv = await loadPlayerDashboardFromCsv({\n        playerId: rawPlayerId,\n        season: seasonValue,\n        splitKey: splitParam,\n      });\n      if (!csv) {\n        return NextResponse.json({ error: \"Player not found\" }, { status: 404 });\n      }\n      return NextResponse.json(csv, {\n        status: 200,\n        headers: { \"x-hotbat-source\": \"csv\" },\n      });\n    }\n\n    const playerId = Number(rawPlayerId);\n    if (Number.isNaN(playerId)) {\n      if (mode === \"auto\") {\n        const csv = await loadPlayerDashboardFromCsv({\n          playerId: rawPlayerId,\n          season: seasonValue,\n          splitKey: splitParam,\n        });\n        if (!csv) {\n          return NextResponse.json({ error: \"Player not found\" }, { status: 404 });\n        }\n        return NextResponse.json(csv, {\n          status: 200,\n          headers: { \"x-hotbat-source\": \"csv\" },\n        });\n      }\n      return NextResponse.json(\n        { error: \"playerId must be a valid integer when HOTBAT_BACKEND=db\" },\n        { status: 400 },\n      );\n    }\n\n    const player = await prisma.player.findUnique({\n      where: { id: playerId },\n      include: { team: true },\n    });\n    if (!player) {\n      return NextResponse.json({ error: \"Player not found\" }, { status: 404 });\n    }\n\n    const summary = await prisma.playerHrSummary.findFirst({\n      where: { playerId, season: seasonValue, splitKey: splitParam },\n      orderBy: { updatedAt: \"desc\" },\n    });\n\n    const summaries = await prisma.playerHrSummary.findMany({\n      where: { playerId, season: seasonValue },\n    });\n\n    const stats = await prisma.playerGameStats.findMany({\n      where: { playerId, season: seasonValue },\n      orderBy: { date: \"desc\" },\n      include: {\n        game: { include: { homeTeam: true, awayTeam: true, park: true } },\n      },\n      take: 10,\n    });\n\n    const hrTimeSeries = [...stats]\n      .reverse()\n      .map((s) => ({\n        date: s.date.toISOString(),\n        gameId: s.gameId,\n        hr: s.hr,\n        xHr: s.xHr ?? null,\n        avgEv: s.avgEv ?? null,\n        opponent:\n          s.game.homeTeamId === s.teamId\n            ? s.game.awayTeam?.name ?? \"Opponent\"\n            : s.game.homeTeam?.name ?? \"Opponent\",\n        park: s.game.park.name,\n      }));\n\n    const recentGames = stats.slice(0, 5).map((s) => ({\n      gameId: s.gameId,\n      date: s.date.toISOString(),\n      opponent:\n        s.game.homeTeamId === s.teamId\n          ? s.game.awayTeam?.name ?? \"Opponent\"\n          : s.game.homeTeam?.name ?? \"Opponent\",\n      park: s.game.park.name,\n      hr: s.hr,\n      xHr: s.xHr ?? null,\n      avgEv: s.avgEv ?? null,\n    }));\n\n    const keyMetrics = [\n      { label: \"HR\", value: summary?.hr ?? 0 },\n      { label: \"xHR\", value: summary?.xHr ?? null },\n      { label: \"HR/PA\", value: summary?.hrPerPa ?? null },\n      { label: \"Barrel%\", value: summary?.barrelRate ?? null },\n      { label: \"Avg EV\", value: summary?.avgEv ?? null },\n      { label: \"ISO\", value: summary?.iso ?? null },\n      { label: \"HardHit%\", value: summary?.hardHitRate ?? null },\n    ];\n\n    const splits: PlayerDashboardResponse[\"splits\"] = {};\n    const targetSummaries = summaries.length > 0 ? summaries : summary ? [summary] : [];\n    for (const s of targetSummaries) {\n      splits[s.splitKey] = {\n        season: s.season,\n        gamesPlayed: s.gamesPlayed,\n        hr: s.hr,\n        xHr: s.xHr ?? null,\n        hrPerPa: s.hrPerPa ?? null,\n        barrelRate: s.barrelRate ?? null,\n        avgEv: s.avgEv ?? null,\n        iso: s.iso ?? null,\n        hardHitRate: s.hardHitRate ?? null,\n      };\n    }\n    if (Object.keys(splits).length === 0) {\n      splits[splitParam] = {\n        season: seasonValue,\n        gamesPlayed: 0,\n        hr: 0,\n        xHr: null,\n        hrPerPa: null,\n        barrelRate: null,\n        avgEv: null,\n        iso: null,\n        hardHitRate: null,\n      };\n    }\n\n    const parkAgg = stats.reduce<Record<string, { hr: number; pa: number; factor?: number | null }>>(\n      (acc, stat) => {\n        const parkName = stat.game.park.name ?? \"Unknown Park\";\n        const hr = stat.hr ?? 0;\n        const pa = stat.pa ?? 0;\n        const factor = stat.game.park.defaultHrFactor ?? null;\n        const current = acc[parkName] ?? { hr: 0, pa: 0, factor };\n        acc[parkName] = {\n          hr: current.hr + hr,\n          pa: current.pa + pa,\n          factor: current.factor ?? factor,\n        };\n        return acc;\n      },\n      {},\n    );\n\n    const parkProfile = Object.entries(parkAgg).map(([parkName, agg]) => ({\n      parkName,\n      hrAtPark: agg.hr,\n      hrPerPaAtPark: agg.pa > 0 ? agg.hr / agg.pa : 0,\n      parkHrFactor: agg.factor,\n    }));\n\n    const seasonHr = summary?.hr ?? 0;\n    const seasonPa = summary?.pa ?? 0;\n    const hrProb = seasonPa > 0 ? seasonHr / seasonPa : 0;\n    const projectedPa = 4.0; // deterministic baseline window\n    const expectedHr = hrProb * projectedPa;\n\n    const response: PlayerDashboardResponse = {\n      playerInfo: {\n        id: player.id,\n        firstName: player.firstName,\n        lastName: player.lastName,\n        bats: player.bats,\n        position: player.position,\n        team: {\n          id: player.team.id,\n          name: player.team.name,\n          abbrev: player.team.abbrev,\n          league: player.team.league,\n          division: player.team.division,\n          logoUrl: logoPath(player.team.abbrev),\n        },\n      },\n      keyMetrics,\n      splits,\n      hrTimeSeries,\n      recentGames,\n      parkProfile,\n      upcomingGames: [],\n      baseline: {\n        hrProb,\n        expectedHr,\n        seasonHr,\n        seasonPa,\n        notes:\n          \"Baseline: HR probability = season HR / season PA; Expected HR = HR probability × 4.0 PA window (deterministic).\",\n      },\n    };\n\n    return NextResponse.json(response);\n  } catch (error) {\n    console.error(\"Error in /api/player-dashboard\", error);\n    return NextResponse.json({ error: \"Internal server error\" }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":"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"}}]
}