{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/arnoldokoye/hotbat/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\nimport { PrismaPg } from \"@prisma/adapter-pg\";\nimport { Pool } from \"pg\";\nimport fs from \"fs\";\nimport path from \"path\";\n\nconst connectionString = process.env.DATABASE_URL;\nif (!connectionString) {\n  throw new Error(\"DATABASE_URL is required to initialize Prisma\");\n}\n\n// Ensure a single PrismaClient/Pool instance across hot reloads in dev.\nconst globalForPrisma = globalThis as unknown as {\n  prisma?: PrismaClient;\n  pool?: Pool;\n  adapter?: PrismaPg;\n  __dbUsedInsecureSsl?: boolean;\n};\n\nconst defaultCaPath =\n  process.env.NODE_EXTRA_CA_CERTS ||\n  path.join(process.cwd(), \"prod-ca-2021.crt\");\nconst caFileExists = defaultCaPath ? fs.existsSync(defaultCaPath) : false;\nconst caBuffer = caFileExists ? fs.readFileSync(defaultCaPath) : undefined;\nconst allowInsecureEnv =\n  process.env.DB_SSL_ALLOW_INSECURE === \"1\" ||\n  process.env.DB_SSL_ALLOW_INSECURE === \"true\" ||\n  process.env.NODE_TLS_REJECT_UNAUTHORIZED === \"0\";\nconst connectionTimeoutMs =\n  Number.parseInt(process.env.DB_CONNECTION_TIMEOUT_MS ?? \"\", 10) || 5000;\n\ntype PoolInit = {\n  pool: Pool;\n  usedInsecure: boolean;\n};\n\nconst buildPool = (rejectUnauthorized: boolean): PoolInit => {\n  const ssl: { rejectUnauthorized: boolean; ca?: Buffer } = { rejectUnauthorized };\n  if (caBuffer) {\n    ssl.ca = caBuffer;\n  }\n  return {\n    pool: new Pool({\n      connectionString,\n      ssl,\n      connectionTimeoutMillis: connectionTimeoutMs,\n    }),\n    usedInsecure: !rejectUnauthorized,\n  };\n};\n\nconst isTlsError = (error: unknown) => {\n  if (!error || typeof error !== \"object\") return false;\n  const code = (error as { code?: string }).code ?? \"\";\n  const message = (error as { message?: string }).message ?? \"\";\n  const tlsCodes = [\n    \"SELF_SIGNED_CERT_IN_CHAIN\",\n    \"DEPTH_ZERO_SELF_SIGNED_CERT\",\n    \"UNABLE_TO_VERIFY_LEAF_SIGNATURE\",\n    \"ERR_TLS_CERT_ALTNAME_INVALID\",\n    \"UNABLE_TO_GET_ISSUER_CERT_LOCALLY\",\n  ];\n  return tlsCodes.includes(code) || message.toLowerCase().includes(\"certificate\");\n};\n\nconst initPool = async (): Promise<PoolInit> => {\n  const primary = buildPool(!allowInsecureEnv);\n\n  const warmupResult = await primary.pool\n    .query(\"SELECT 1\")\n    .then(() => \"ok\" as const)\n    .catch((error) => {\n      if (!allowInsecureEnv && isTlsError(error)) {\n        return \"tls-error\" as const;\n      }\n      console.warn(\n        \"Database warm-up query failed; continuing with current SSL config.\",\n        error,\n      );\n      return \"failed\" as const;\n    });\n\n  if (warmupResult === \"tls-error\") {\n    await primary.pool.end().catch(() => {});\n    console.warn(\n      \"Database TLS verification failed; retrying with rejectUnauthorized=false. \" +\n        \"Provide NODE_EXTRA_CA_CERTS with your trusted root to restore verification.\",\n    );\n    return buildPool(false);\n  }\n\n  return primary;\n};\n\nconst { pool, usedInsecure } =\n  globalForPrisma.pool && typeof globalForPrisma.__dbUsedInsecureSsl === \"boolean\"\n    ? { pool: globalForPrisma.pool, usedInsecure: globalForPrisma.__dbUsedInsecureSsl }\n    : await initPool();\n\nconst adapter = globalForPrisma.adapter ?? new PrismaPg(pool);\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    adapter,\n    log: process.env.NODE_ENV === \"development\" ? [\"warn\", \"error\"] : [\"error\"],\n  });\n\nif (process.env.NODE_ENV !== \"production\") {\n  globalForPrisma.pool = pool;\n  globalForPrisma.adapter = adapter;\n  globalForPrisma.prisma = prisma;\n  globalForPrisma.__dbUsedInsecureSsl = usedInsecure;\n}\n\nexport default prisma;\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAEA,MAAM,mBAAmB,QAAQ,GAAG,CAAC,YAAY;AACjD,IAAI,CAAC,kBAAkB;IACrB,MAAM,IAAI,MAAM;AAClB;AAEA,wEAAwE;AACxE,MAAM,kBAAkB;AAOxB,MAAM,gBACJ,QAAQ,GAAG,CAAC,mBAAmB,IAC/B,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;AAC3B,MAAM,eAAe,uCAAgB,wGAAE,CAAC,UAAU,CAAC,iBAAiB;AACpE,MAAM,WAAW,eAAe,wGAAE,CAAC,YAAY,CAAC,iBAAiB;AACjE,MAAM,mBACJ,QAAQ,GAAG,CAAC,qBAAqB,KAAK,OACtC,QAAQ,GAAG,CAAC,qBAAqB,KAAK,UACtC,QAAQ,GAAG,CAAC,4BAA4B,KAAK;AAC/C,MAAM,sBACJ,OAAO,QAAQ,CAAC,QAAQ,GAAG,CAAC,wBAAwB,IAAI,IAAI,OAAO;AAOrE,MAAM,YAAY,CAAC;IACjB,MAAM,MAAoD;QAAE;IAAmB;IAC/E,IAAI,UAAU;QACZ,IAAI,EAAE,GAAG;IACX;IACA,OAAO;QACL,MAAM,IAAI,4GAAI,CAAC;YACb;YACA;YACA,yBAAyB;QAC3B;QACA,cAAc,CAAC;IACjB;AACF;AAEA,MAAM,aAAa,CAAC;IAClB,IAAI,CAAC,SAAS,OAAO,UAAU,UAAU,OAAO;IAChD,MAAM,OAAO,AAAC,MAA4B,IAAI,IAAI;IAClD,MAAM,UAAU,AAAC,MAA+B,OAAO,IAAI;IAC3D,MAAM,WAAW;QACf;QACA;QACA;QACA;QACA;KACD;IACD,OAAO,SAAS,QAAQ,CAAC,SAAS,QAAQ,WAAW,GAAG,QAAQ,CAAC;AACnE;AAEA,MAAM,WAAW;IACf,MAAM,UAAU,UAAU,CAAC;IAE3B,MAAM,eAAe,MAAM,QAAQ,IAAI,CACpC,KAAK,CAAC,YACN,IAAI,CAAC,IAAM,MACX,KAAK,CAAC,CAAC;QACN,IAAI,CAAC,oBAAoB,WAAW,QAAQ;YAC1C,OAAO;QACT;QACA,QAAQ,IAAI,CACV,sEACA;QAEF,OAAO;IACT;IAEF,IAAI,iBAAiB,aAAa;QAChC,MAAM,QAAQ,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,KAAO;QACtC,QAAQ,IAAI,CACV,+EACE;QAEJ,OAAO,UAAU;IACnB;IAEA,OAAO;AACT;AAEA,MAAM,EAAE,IAAI,EAAE,YAAY,EAAE,GAC1B,gBAAgB,IAAI,IAAI,OAAO,gBAAgB,mBAAmB,KAAK,YACnE;IAAE,MAAM,gBAAgB,IAAI;IAAE,cAAc,gBAAgB,mBAAmB;AAAC,IAChF,MAAM;AAEZ,MAAM,UAAU,gBAAgB,OAAO,IAAI,IAAI,yKAAQ,CAAC;AAEjD,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf;IACA,KAAK,uCAAyC;QAAC;QAAQ;KAAQ,GAAG;AACpE;AAEF,wCAA2C;IACzC,gBAAgB,IAAI,GAAG;IACvB,gBAAgB,OAAO,GAAG;IAC1B,gBAAgB,MAAM,GAAG;IACzB,gBAAgB,mBAAmB,GAAG;AACxC;uCAEe"}},
    {"offset": {"line": 189, "column": 0}, "map": {"version":3,"sources":["file:///Users/arnoldokoye/hotbat/src/lib/csv/ballparks.ts"],"sourcesContent":["import fs from \"node:fs/promises\";\nimport path from \"node:path\";\n\nconst GAMELOGS_DIR = path.join(process.cwd(), \"data_sources\", \"NEW_DATA_SETS\", \"2020-25 GAMELOGS\");\nconst BALLPARKS_CSV_PATH = path.join(GAMELOGS_DIR, \"ballparks.csv\");\n\nlet cache: { mtimeMs: number; byParkId: Map<string, string> } | null = null;\n\nfunction splitCsvLine(line: string): string[] {\n  const out: string[] = [];\n  let cur = \"\";\n  let inQuotes = false;\n\n  for (let i = 0; i < line.length; i += 1) {\n    const ch = line[i];\n\n    if (ch === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        cur += '\"';\n        i += 1;\n        continue;\n      }\n      inQuotes = !inQuotes;\n      continue;\n    }\n\n    if (ch === \",\" && !inQuotes) {\n      out.push(cur);\n      cur = \"\";\n      continue;\n    }\n\n    cur += ch;\n  }\n\n  out.push(cur);\n  return out;\n}\n\nexport async function loadBallparks(): Promise<Map<string, string>> {\n  const stat = await fs.stat(BALLPARKS_CSV_PATH);\n  if (cache && cache.mtimeMs === stat.mtimeMs) return cache.byParkId;\n\n  const csvText = await fs.readFile(BALLPARKS_CSV_PATH, \"utf8\");\n  const text = csvText.replace(/^\\uFEFF/, \"\").trim();\n  const lines = text.split(/\\r?\\n/).filter(Boolean);\n  if (lines.length < 2) throw new Error(`ballparks.csv is empty: ${BALLPARKS_CSV_PATH}`);\n\n  const header = splitCsvLine(lines[0]).map((h) => h.trim().toUpperCase());\n  const idx = new Map(header.map((h, i) => [h, i]));\n\n  function cell(cols: string[], key: string): string {\n    const i = idx.get(key);\n    return i === undefined ? \"\" : (cols[i] ?? \"\").trim();\n  }\n\n  const byParkId = new Map<string, string>();\n  for (const line of lines.slice(1)) {\n    const cols = splitCsvLine(line);\n    const parkId = cell(cols, \"PARKID\");\n    const name = cell(cols, \"NAME\");\n    if (!parkId || !name) continue;\n    if (!byParkId.has(parkId)) byParkId.set(parkId, name);\n  }\n\n  cache = { mtimeMs: stat.mtimeMs, byParkId };\n  return byParkId;\n}\n\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,MAAM,eAAe,4HAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,gBAAgB,iBAAiB;AAC/E,MAAM,qBAAqB,4HAAI,CAAC,IAAI,CAAC,cAAc;AAEnD,IAAI,QAAmE;AAEvE,SAAS,aAAa,IAAY;IAChC,MAAM,MAAgB,EAAE;IACxB,IAAI,MAAM;IACV,IAAI,WAAW;IAEf,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,KAAK,EAAG;QACvC,MAAM,KAAK,IAAI,CAAC,EAAE;QAElB,IAAI,OAAO,KAAK;YACd,IAAI,YAAY,IAAI,CAAC,IAAI,EAAE,KAAK,KAAK;gBACnC,OAAO;gBACP,KAAK;gBACL;YACF;YACA,WAAW,CAAC;YACZ;QACF;QAEA,IAAI,OAAO,OAAO,CAAC,UAAU;YAC3B,IAAI,IAAI,CAAC;YACT,MAAM;YACN;QACF;QAEA,OAAO;IACT;IAEA,IAAI,IAAI,CAAC;IACT,OAAO;AACT;AAEO,eAAe;IACpB,MAAM,OAAO,MAAM,gJAAE,CAAC,IAAI,CAAC;IAC3B,IAAI,SAAS,MAAM,OAAO,KAAK,KAAK,OAAO,EAAE,OAAO,MAAM,QAAQ;IAElE,MAAM,UAAU,MAAM,gJAAE,CAAC,QAAQ,CAAC,oBAAoB;IACtD,MAAM,OAAO,QAAQ,OAAO,CAAC,WAAW,IAAI,IAAI;IAChD,MAAM,QAAQ,KAAK,KAAK,CAAC,SAAS,MAAM,CAAC;IACzC,IAAI,MAAM,MAAM,GAAG,GAAG,MAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,oBAAoB;IAErF,MAAM,SAAS,aAAa,KAAK,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI,GAAG,WAAW;IACrE,MAAM,MAAM,IAAI,IAAI,OAAO,GAAG,CAAC,CAAC,GAAG,IAAM;YAAC;YAAG;SAAE;IAE/C,SAAS,KAAK,IAAc,EAAE,GAAW;QACvC,MAAM,IAAI,IAAI,GAAG,CAAC;QAClB,OAAO,MAAM,YAAY,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,EAAE,IAAI;IACpD;IAEA,MAAM,WAAW,IAAI;IACrB,KAAK,MAAM,QAAQ,MAAM,KAAK,CAAC,GAAI;QACjC,MAAM,OAAO,aAAa;QAC1B,MAAM,SAAS,KAAK,MAAM;QAC1B,MAAM,OAAO,KAAK,MAAM;QACxB,IAAI,CAAC,UAAU,CAAC,MAAM;QACtB,IAAI,CAAC,SAAS,GAAG,CAAC,SAAS,SAAS,GAAG,CAAC,QAAQ;IAClD;IAEA,QAAQ;QAAE,SAAS,KAAK,OAAO;QAAE;IAAS;IAC1C,OAAO;AACT"}},
    {"offset": {"line": 259, "column": 0}, "map": {"version":3,"sources":["file:///Users/arnoldokoye/hotbat/src/lib/csv/csv.ts"],"sourcesContent":["import fs from \"node:fs/promises\";\n\nexport function splitCsvLine(line: string): string[] {\n  const out: string[] = [];\n  let cur = \"\";\n  let inQuotes = false;\n\n  for (let i = 0; i < line.length; i += 1) {\n    const ch = line[i];\n\n    if (ch === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        cur += '\"';\n        i += 1;\n        continue;\n      }\n      inQuotes = !inQuotes;\n      continue;\n    }\n\n    if (ch === \",\" && !inQuotes) {\n      out.push(cur);\n      cur = \"\";\n      continue;\n    }\n\n    cur += ch;\n  }\n\n  out.push(cur);\n  return out;\n}\n\nexport function parseCsvText(text: string): { header: string[]; rows: string[][] } {\n  const stripped = text.replace(/^\\uFEFF/, \"\").trim();\n  if (!stripped) return { header: [], rows: [] };\n\n  const lines = stripped.split(/\\r?\\n/).filter(Boolean);\n  if (lines.length === 0) return { header: [], rows: [] };\n\n  const header = splitCsvLine(lines[0]).map((h) => h.trim());\n  const rows = lines.slice(1).map((line) => splitCsvLine(line).map((c) => c.trim()));\n  return { header, rows };\n}\n\nexport async function readCsvFile(filePath: string): Promise<{ header: string[]; rows: string[][]; mtimeMs: number }> {\n  const stat = await fs.stat(filePath);\n  const text = await fs.readFile(filePath, \"utf8\");\n  const { header, rows } = parseCsvText(text);\n  return { header, rows, mtimeMs: stat.mtimeMs };\n}\n\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEO,SAAS,aAAa,IAAY;IACvC,MAAM,MAAgB,EAAE;IACxB,IAAI,MAAM;IACV,IAAI,WAAW;IAEf,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,KAAK,EAAG;QACvC,MAAM,KAAK,IAAI,CAAC,EAAE;QAElB,IAAI,OAAO,KAAK;YACd,IAAI,YAAY,IAAI,CAAC,IAAI,EAAE,KAAK,KAAK;gBACnC,OAAO;gBACP,KAAK;gBACL;YACF;YACA,WAAW,CAAC;YACZ;QACF;QAEA,IAAI,OAAO,OAAO,CAAC,UAAU;YAC3B,IAAI,IAAI,CAAC;YACT,MAAM;YACN;QACF;QAEA,OAAO;IACT;IAEA,IAAI,IAAI,CAAC;IACT,OAAO;AACT;AAEO,SAAS,aAAa,IAAY;IACvC,MAAM,WAAW,KAAK,OAAO,CAAC,WAAW,IAAI,IAAI;IACjD,IAAI,CAAC,UAAU,OAAO;QAAE,QAAQ,EAAE;QAAE,MAAM,EAAE;IAAC;IAE7C,MAAM,QAAQ,SAAS,KAAK,CAAC,SAAS,MAAM,CAAC;IAC7C,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO;QAAE,QAAQ,EAAE;QAAE,MAAM,EAAE;IAAC;IAEtD,MAAM,SAAS,aAAa,KAAK,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI;IACvD,MAAM,OAAO,MAAM,KAAK,CAAC,GAAG,GAAG,CAAC,CAAC,OAAS,aAAa,MAAM,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI;IAC9E,OAAO;QAAE;QAAQ;IAAK;AACxB;AAEO,eAAe,YAAY,QAAgB;IAChD,MAAM,OAAO,MAAM,gJAAE,CAAC,IAAI,CAAC;IAC3B,MAAM,OAAO,MAAM,gJAAE,CAAC,QAAQ,CAAC,UAAU;IACzC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,aAAa;IACtC,OAAO;QAAE;QAAQ;QAAM,SAAS,KAAK,OAAO;IAAC;AAC/C"}},
    {"offset": {"line": 326, "column": 0}, "map": {"version":3,"sources":["file:///Users/arnoldokoye/hotbat/src/lib/csv/dailyTeamStats.ts"],"sourcesContent":["import path from \"node:path\";\n\nimport { readCsvFile } from \"@/lib/csv/csv\";\n\nconst DAILY_LOGS_DIR = path.join(process.cwd(), \"data_sources\", \"NEW_DATA_SETS\", \"2020-25 DAILY LOGS\");\n\nexport type DailyTeamStatsRow = {\n  gid: string;\n  team_id: string;\n  opp: string;\n  vishome: \"h\" | \"v\" | \"\";\n  site: string;\n  date: string; // YYYYMMDD\n  b_hr: number;\n  b_pa: number;\n  win: number;\n  loss: number;\n  tie: number;\n};\n\nlet cache:\n  | {\n      season: number;\n      mtimeMs: number;\n      rows: DailyTeamStatsRow[];\n    }\n  | null = null;\n\nfunction asInt(value: string): number {\n  const n = Number.parseInt(value, 10);\n  return Number.isFinite(n) ? n : 0;\n}\n\nexport async function loadDailyTeamStats(season: number): Promise<DailyTeamStatsRow[]> {\n  const filePath = path.join(DAILY_LOGS_DIR, `${season}DAILY_LOGScsvs`, `${season}teamstats.csv`);\n  const { header, rows, mtimeMs } = await readCsvFile(filePath);\n\n  if (cache && cache.season === season && cache.mtimeMs === mtimeMs) return cache.rows;\n\n  const idx = new Map(header.map((h, i) => [h, i] as const));\n  const cell = (cols: string[], key: string) => {\n    const i = idx.get(key);\n    return i === undefined ? \"\" : (cols[i] ?? \"\");\n  };\n\n  const parsed: DailyTeamStatsRow[] = [];\n  for (const cols of rows) {\n    const stattype = cell(cols, \"stattype\").toLowerCase();\n    if (stattype && stattype !== \"value\") continue;\n\n    const gid = cell(cols, \"gid\");\n    const team_id = cell(cols, \"team\");\n    const opp = cell(cols, \"opp\");\n    const vishome = cell(cols, \"vishome\") as DailyTeamStatsRow[\"vishome\"];\n    const site = cell(cols, \"site\");\n    const date = cell(cols, \"date\");\n\n    if (!gid || !team_id || !date) continue;\n\n    parsed.push({\n      gid,\n      team_id,\n      opp,\n      vishome: vishome === \"h\" || vishome === \"v\" ? vishome : \"\",\n      site,\n      date,\n      b_hr: asInt(cell(cols, \"b_hr\")),\n      b_pa: asInt(cell(cols, \"b_pa\")),\n      win: asInt(cell(cols, \"win\")),\n      loss: asInt(cell(cols, \"loss\")),\n      tie: asInt(cell(cols, \"tie\")),\n    });\n  }\n\n  // Deterministic ordering.\n  parsed.sort((a, b) => {\n    if (a.date !== b.date) return a.date.localeCompare(b.date);\n    if (a.gid !== b.gid) return a.gid.localeCompare(b.gid);\n    return a.team_id.localeCompare(b.team_id);\n  });\n\n  cache = { season, mtimeMs, rows: parsed };\n  return parsed;\n}\n\n"],"names":[],"mappings":";;;;AAAA;AAEA;;;AAEA,MAAM,iBAAiB,4HAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,gBAAgB,iBAAiB;AAgBjF,IAAI,QAMO;AAEX,SAAS,MAAM,KAAa;IAC1B,MAAM,IAAI,OAAO,QAAQ,CAAC,OAAO;IACjC,OAAO,OAAO,QAAQ,CAAC,KAAK,IAAI;AAClC;AAEO,eAAe,mBAAmB,MAAc;IACrD,MAAM,WAAW,4HAAI,CAAC,IAAI,CAAC,gBAAgB,GAAG,OAAO,cAAc,CAAC,EAAE,GAAG,OAAO,aAAa,CAAC;IAC9F,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,yIAAW,EAAC;IAEpD,IAAI,SAAS,MAAM,MAAM,KAAK,UAAU,MAAM,OAAO,KAAK,SAAS,OAAO,MAAM,IAAI;IAEpF,MAAM,MAAM,IAAI,IAAI,OAAO,GAAG,CAAC,CAAC,GAAG,IAAM;YAAC;YAAG;SAAE;IAC/C,MAAM,OAAO,CAAC,MAAgB;QAC5B,MAAM,IAAI,IAAI,GAAG,CAAC;QAClB,OAAO,MAAM,YAAY,KAAM,IAAI,CAAC,EAAE,IAAI;IAC5C;IAEA,MAAM,SAA8B,EAAE;IACtC,KAAK,MAAM,QAAQ,KAAM;QACvB,MAAM,WAAW,KAAK,MAAM,YAAY,WAAW;QACnD,IAAI,YAAY,aAAa,SAAS;QAEtC,MAAM,MAAM,KAAK,MAAM;QACvB,MAAM,UAAU,KAAK,MAAM;QAC3B,MAAM,MAAM,KAAK,MAAM;QACvB,MAAM,UAAU,KAAK,MAAM;QAC3B,MAAM,OAAO,KAAK,MAAM;QACxB,MAAM,OAAO,KAAK,MAAM;QAExB,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,MAAM;QAE/B,OAAO,IAAI,CAAC;YACV;YACA;YACA;YACA,SAAS,YAAY,OAAO,YAAY,MAAM,UAAU;YACxD;YACA;YACA,MAAM,MAAM,KAAK,MAAM;YACvB,MAAM,MAAM,KAAK,MAAM;YACvB,KAAK,MAAM,KAAK,MAAM;YACtB,MAAM,MAAM,KAAK,MAAM;YACvB,KAAK,MAAM,KAAK,MAAM;QACxB;IACF;IAEA,0BAA0B;IAC1B,OAAO,IAAI,CAAC,CAAC,GAAG;QACd,IAAI,EAAE,IAAI,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,aAAa,CAAC,EAAE,IAAI;QACzD,IAAI,EAAE,GAAG,KAAK,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,CAAC,aAAa,CAAC,EAAE,GAAG;QACrD,OAAO,EAAE,OAAO,CAAC,aAAa,CAAC,EAAE,OAAO;IAC1C;IAEA,QAAQ;QAAE;QAAQ;QAAS,MAAM;IAAO;IACxC,OAAO;AACT"}},
    {"offset": {"line": 394, "column": 0}, "map": {"version":3,"sources":["file:///Users/arnoldokoye/hotbat/src/lib/csv/teams.ts"],"sourcesContent":["import fs from \"node:fs/promises\";\nimport path from \"node:path\";\n\nimport type { TeamSummary } from \"@/lib/backend/DataBackend\";\n\nconst GAMELOGS_DIR = path.join(process.cwd(), \"data_sources\", \"NEW_DATA_SETS\", \"2020-25 GAMELOGS\");\nconst TEAMS_CSV_PATH = path.join(GAMELOGS_DIR, \"teams.csv\");\n\nlet cache:\n  | {\n      mtimeMs: number;\n      teams: TeamSummary[];\n    }\n  | null = null;\n\nfunction splitCsvLine(line: string): string[] {\n  const out: string[] = [];\n  let cur = \"\";\n  let inQuotes = false;\n\n  for (let i = 0; i < line.length; i += 1) {\n    const ch = line[i];\n\n    if (ch === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        cur += '\"';\n        i += 1;\n        continue;\n      }\n      inQuotes = !inQuotes;\n      continue;\n    }\n\n    if (ch === \",\" && !inQuotes) {\n      out.push(cur);\n      cur = \"\";\n      continue;\n    }\n\n    cur += ch;\n  }\n\n  out.push(cur);\n  return out;\n}\n\nfunction parseIntSafe(value: string): number | null {\n  const v = value.trim();\n  if (!v) return null;\n  const n = Number.parseInt(v, 10);\n  return Number.isFinite(n) ? n : null;\n}\n\nexport async function loadTeams(options?: {\n  minSeason?: number;\n  maxSeason?: number;\n  leagues?: string[];\n}): Promise<TeamSummary[]> {\n  const stat = await fs.stat(TEAMS_CSV_PATH);\n  if (cache && cache.mtimeMs === stat.mtimeMs) return cache.teams;\n\n  const csvText = await fs.readFile(TEAMS_CSV_PATH, \"utf8\");\n  const text = csvText.replace(/^\\uFEFF/, \"\").trim();\n  if (!text) {\n    cache = { mtimeMs: stat.mtimeMs, teams: [] };\n    return [];\n  }\n\n  const lines = text.split(/\\r?\\n/).filter(Boolean);\n  if (lines.length < 2) {\n    cache = { mtimeMs: stat.mtimeMs, teams: [] };\n    return [];\n  }\n\n  const header = splitCsvLine(lines[0]).map((h) => h.trim().toUpperCase());\n  const idx = new Map(header.map((h, i) => [h, i]));\n\n  function cell(cols: string[], key: string): string {\n    const i = idx.get(key);\n    return i === undefined ? \"\" : (cols[i] ?? \"\").trim();\n  }\n\n  const minSeason = options?.minSeason ?? 2020;\n  const maxSeason = options?.maxSeason ?? 2025;\n  const leagues =\n    options?.leagues?.map((l) => l.trim().toUpperCase()).filter(Boolean) ?? [\"AL\", \"NL\"];\n\n  type Candidate = { first: number; last: number; league: string | null; name: string };\n  const bestByTeam = new Map<string, Candidate>();\n\n  for (const line of lines.slice(1)) {\n    const cols = splitCsvLine(line);\n    const team_id = cell(cols, \"TEAM\");\n    const league = cell(cols, \"LEAGUE\").toUpperCase();\n    const city = cell(cols, \"CITY\");\n    const nickname = cell(cols, \"NICKNAME\");\n    const first = parseIntSafe(cell(cols, \"FIRST\")) ?? 0;\n    const last = parseIntSafe(cell(cols, \"LAST\")) ?? 9999;\n    if (!team_id || !city || !nickname) continue;\n    if (leagues.length && league && !leagues.includes(league)) continue;\n    if (last < minSeason || first > maxSeason) continue;\n\n    const name = `${city} ${nickname}`;\n    const cand: Candidate = { first, last, league: league || null, name };\n    const existing = bestByTeam.get(team_id);\n    if (!existing) {\n      bestByTeam.set(team_id, cand);\n      continue;\n    }\n    // Prefer the most recent era (highest FIRST), then lexicographic name for determinism.\n    if (cand.first > existing.first) {\n      bestByTeam.set(team_id, cand);\n    } else if (cand.first === existing.first && cand.name < existing.name) {\n      bestByTeam.set(team_id, cand);\n    }\n  }\n\n  const teams: TeamSummary[] = Array.from(bestByTeam.entries()).map(([team_id, cand]) => ({\n    team_id,\n    team_name: cand.name,\n    league: cand.league,\n  }));\n\n  teams.sort((a, b) => {\n    if (a.team_name !== b.team_name) return a.team_name.localeCompare(b.team_name);\n    return a.team_id.localeCompare(b.team_id);\n  });\n\n  cache = { mtimeMs: stat.mtimeMs, teams };\n  return teams;\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 523, "column": 0}, "map": {"version":3,"sources":["file:///Users/arnoldokoye/hotbat/src/app/api/team-dashboard/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport prisma from \"@/lib/prisma\";\nimport { loadBallparks } from \"@/lib/csv/ballparks\";\nimport { loadDailyTeamStats } from \"@/lib/csv/dailyTeamStats\";\nimport { loadTeams } from \"@/lib/csv/teams\";\n\ntype TeamDashboardResponse = {\n  teamInfo: {\n    id: number;\n    name: string;\n    abbrev: string;\n    league: string;\n    division: string;\n    logoUrl?: string;\n  };\n  keyMetrics: {\n    id: string;\n    label: string;\n    value: string;\n    comparisonText?: string;\n    trendDirection?: \"up\" | \"down\" | \"flat\";\n  }[];\n  hrTimeSeries: {\n    date: string;\n    hr: number;\n    xHr?: number;\n    avgEv?: number;\n    barrels?: number;\n  }[];\n  pitcherVulnerability: {\n    pitcherName: string;\n    pitcherTeam: string;\n    hrAllowed: number;\n    hrPer9: number;\n    avgEvAllowed?: number;\n    maxDistance?: number;\n  }[];\n  upcomingGames: {\n    gameId: number;\n    date: string;\n    opponentName: string;\n    opponentAbbrev: string;\n    parkName: string;\n    parkHrFactor?: number;\n    predictedHrMean?: number;\n    predictedHrStd?: number;\n    hotbatScore?: number;\n  }[];\n  splits: {\n    overview: { label: string; hrPerGame: number; leagueAvgHrPerGame?: number }[];\n    homeAway: { label: string; hrPerGame: number; leagueAvgHrPerGame?: number }[];\n    lhpRhp: { label: string; hrPerGame: number; leagueAvgHrPerGame?: number }[];\n    monthly: { label: string; hrPerGame: number; leagueAvgHrPerGame?: number }[];\n  };\n  games: {\n    id: number;\n    date: string;\n    opponent: string;\n    park: string;\n    result?: string;\n    hr: number;\n    xHr?: number;\n    hrDiff?: number;\n    opposingSp?: string;\n    opposingSpHr9?: number;\n  }[];\n};\n\nconst parseDate = (value: string | null) => {\n  if (!value) return undefined;\n  const parsed = new Date(value);\n  return Number.isNaN(parsed.getTime()) ? null : parsed;\n};\n\nconst logoPath = (abbrev?: string | null) => {\n  return abbrev\n    ? `/team-logos/${abbrev.toLowerCase()}.svg`\n    : \"/team-logos/default.svg\";\n};\n\nconst logoFromRetrosheetTeam = (teamId: string) => {\n  const id = teamId.trim().toUpperCase();\n  if (id === \"NYA\") return logoPath(\"nyy\");\n  if (id === \"BOS\") return logoPath(\"bos\");\n  return logoPath(null);\n};\n\nfunction yyyymmddToIsoDate(value: string): string | null {\n  const v = value.trim();\n  if (!/^\\d{8}$/.test(v)) return null;\n  return `${v.slice(0, 4)}-${v.slice(4, 6)}-${v.slice(6, 8)}`;\n}\n\nfunction isoDateToTimestamp(value: string): string {\n  return `${value}T00:00:00.000Z`;\n}\n\nfunction hash32FNV1a(input: string): number {\n  let hash = 0x811c9dc5;\n  for (let i = 0; i < input.length; i += 1) {\n    hash ^= input.charCodeAt(i);\n    hash = Math.imul(hash, 0x01000193);\n  }\n  return hash >>> 0;\n}\n\nfunction safeDiv(numer: number, denom: number): number | null {\n  if (!Number.isFinite(numer) || !Number.isFinite(denom) || denom <= 0) return null;\n  return numer / denom;\n}\n\nasync function loadTeamDashboardFromCsv(args: {\n  teamId: string;\n  season: number;\n  from: Date | undefined;\n  to: Date | undefined;\n  splitKey: string;\n}): Promise<TeamDashboardResponse | null> {\n  const { teamId, season, from, to, splitKey: _splitKey } = args;\n  void _splitKey;\n\n  const [rows, teams, parks] = await Promise.all([\n    loadDailyTeamStats(season),\n    loadTeams().catch(() => []),\n    loadBallparks().catch(() => new Map<string, string>()),\n  ]);\n\n  const teamNameById = new Map(teams.map((t) => [t.team_id, t.team_name] as const));\n  const teamLeagueById = new Map(teams.map((t) => [t.team_id, t.league] as const));\n\n  const fromIso = from ? from.toISOString().slice(0, 10) : null;\n  const toIso = to ? to.toISOString().slice(0, 10) : null;\n\n  type TeamGame = {\n    gid: string;\n    date: string; // ISO YYYY-MM-DD\n    opp: string;\n    vishome: \"h\" | \"v\" | \"\";\n    site: string;\n    hr: number;\n    pa: number;\n    win: number;\n    loss: number;\n    tie: number;\n  };\n\n  const byGid = new Map<string, TeamGame>();\n\n  for (const row of rows) {\n    if (row.team_id !== teamId) continue;\n    const dateIso = yyyymmddToIsoDate(row.date);\n    if (!dateIso) continue;\n    if (fromIso && dateIso < fromIso) continue;\n    if (toIso && dateIso > toIso) continue;\n\n    const existing = byGid.get(row.gid);\n    if (existing) {\n      existing.hr += row.b_hr;\n      existing.pa += row.b_pa;\n      existing.win = existing.win || row.win;\n      existing.loss = existing.loss || row.loss;\n      existing.tie = existing.tie || row.tie;\n      continue;\n    }\n\n    byGid.set(row.gid, {\n      gid: row.gid,\n      date: dateIso,\n      opp: row.opp,\n      vishome: row.vishome,\n      site: row.site,\n      hr: row.b_hr,\n      pa: row.b_pa,\n      win: row.win,\n      loss: row.loss,\n      tie: row.tie,\n    });\n  }\n\n  const games = Array.from(byGid.values());\n  games.sort((a, b) => {\n    if (a.date !== b.date) return a.date.localeCompare(b.date);\n    return a.gid.localeCompare(b.gid);\n  });\n\n  if (!games.length) return null;\n\n  const gamesPlayed = games.length;\n  const totalHr = games.reduce((sum, g) => sum + g.hr, 0);\n  const hrPerGame = safeDiv(totalHr, gamesPlayed) ?? 0;\n\n  const homeGames = games.filter((g) => g.vishome === \"h\");\n  const awayGames = games.filter((g) => g.vishome === \"v\");\n  const homeHrPerGame = safeDiv(homeGames.reduce((sum, g) => sum + g.hr, 0), homeGames.length) ?? 0;\n  const awayHrPerGame = safeDiv(awayGames.reduce((sum, g) => sum + g.hr, 0), awayGames.length) ?? 0;\n\n  const monthlyAgg = games.reduce<Record<string, { hr: number; games: number }>>((acc, g) => {\n    const key = g.date.slice(0, 7);\n    acc[key] ??= { hr: 0, games: 0 };\n    acc[key].hr += g.hr;\n    acc[key].games += 1;\n    return acc;\n  }, {});\n\n  const monthly = Object.entries(monthlyAgg)\n    .sort(([a], [b]) => a.localeCompare(b))\n    .map(([month, agg]) => ({ label: month, hrPerGame: safeDiv(agg.hr, agg.games) ?? 0 }));\n\n  const teamName = teamNameById.get(teamId) ?? teamId;\n  const league = teamLeagueById.get(teamId) ?? \"\";\n\n  const keyMetrics: TeamDashboardResponse[\"keyMetrics\"] = [\n    { id: \"hr_per_game\", label: \"HR/Game\", value: hrPerGame.toFixed(2) },\n    { id: \"games_played\", label: \"Games\", value: gamesPlayed.toString() },\n    { id: \"total_hr\", label: \"Total HR\", value: totalHr.toString() },\n  ];\n\n  const hrTimeSeries: TeamDashboardResponse[\"hrTimeSeries\"] = games.map((g) => ({\n    date: isoDateToTimestamp(g.date),\n    hr: g.hr,\n  }));\n\n  const gamesTable: TeamDashboardResponse[\"games\"] = games\n    .slice()\n    .sort((a, b) => {\n      if (a.date !== b.date) return b.date.localeCompare(a.date);\n      return b.gid.localeCompare(a.gid);\n    })\n    .map((g) => {\n      const result = g.win ? \"W\" : g.loss ? \"L\" : g.tie ? \"T\" : undefined;\n      return {\n        id: hash32FNV1a(g.gid),\n        date: isoDateToTimestamp(g.date),\n        opponent: teamNameById.get(g.opp) ?? g.opp ?? \"Opponent\",\n        park: parks.get(g.site) ?? g.site ?? \"Park\",\n        result,\n        hr: g.hr,\n      };\n    });\n\n  const response: TeamDashboardResponse = {\n    teamInfo: {\n      id: 0,\n      name: teamName,\n      abbrev: teamId,\n      league: league ?? \"\",\n      division: \"â€”\",\n      logoUrl: logoFromRetrosheetTeam(teamId),\n    },\n    keyMetrics,\n    hrTimeSeries,\n    pitcherVulnerability: [],\n    upcomingGames: [],\n    splits: {\n      overview: [\n        { label: \"Overall HR/G\", hrPerGame },\n        { label: \"Home HR/G\", hrPerGame: homeHrPerGame },\n        { label: \"Away HR/G\", hrPerGame: awayHrPerGame },\n      ],\n      homeAway: [\n        { label: \"Home HR/G\", hrPerGame: homeHrPerGame },\n        { label: \"Away HR/G\", hrPerGame: awayHrPerGame },\n      ],\n      lhpRhp: [],\n      monthly,\n    },\n    games: gamesTable,\n  };\n\n  return response;\n}\n\nexport async function GET(req: NextRequest) {\n  const { searchParams } = new URL(req.url);\n  const teamIdParam = searchParams.get(\"teamId\");\n  const teamIdAlt = searchParams.get(\"team_id\");\n  const seasonParam = searchParams.get(\"season\");\n  const splitParam = searchParams.get(\"split\") ?? \"overall\";\n  const fromParam = searchParams.get(\"from\");\n  const toParam = searchParams.get(\"to\");\n\n  const seasonParsed = seasonParam ? Number(seasonParam) : undefined;\n  if (seasonParam && Number.isNaN(seasonParsed)) {\n    return NextResponse.json(\n      { error: \"season must be a number when provided\" },\n      { status: 400 },\n    );\n  }\n  const seasonValue = typeof seasonParsed === \"number\" ? seasonParsed : 2024;\n  const season = seasonParam ? seasonValue : undefined;\n\n  const fromDate = parseDate(fromParam);\n  const toDate = parseDate(toParam);\n  if (fromParam && fromDate === null) {\n    return NextResponse.json(\n      { error: \"from must be a valid date (YYYY-MM-DD)\" },\n      { status: 400 },\n    );\n  }\n  if (toParam && toDate === null) {\n    return NextResponse.json(\n      { error: \"to must be a valid date (YYYY-MM-DD)\" },\n      { status: 400 },\n    );\n  }\n\n  const mode = (process.env.HOTBAT_BACKEND ?? \"auto\").toLowerCase();\n  const rawTeamId = (teamIdAlt ?? teamIdParam ?? \"\").trim();\n  if (!rawTeamId) {\n    return NextResponse.json({ error: \"teamId query param is required\" }, { status: 400 });\n  }\n\n  if (mode === \"csv\" || (teamIdAlt && mode !== \"db\")) {\n    const csv = await loadTeamDashboardFromCsv({\n      teamId: rawTeamId,\n      season: seasonValue,\n      from: fromDate === null ? undefined : fromDate,\n      to: toDate === null ? undefined : toDate,\n      splitKey: splitParam,\n    });\n    if (!csv) return NextResponse.json({ error: \"Team not found\" }, { status: 404 });\n    return NextResponse.json(csv, { status: 200, headers: { \"x-hotbat-source\": \"csv\" } });\n  }\n\n  const teamId = Number(rawTeamId);\n  if (Number.isNaN(teamId)) {\n    if (mode === \"auto\") {\n      const csv = await loadTeamDashboardFromCsv({\n        teamId: rawTeamId,\n        season: seasonValue,\n        from: fromDate === null ? undefined : fromDate,\n        to: toDate === null ? undefined : toDate,\n        splitKey: splitParam,\n      });\n      if (!csv) return NextResponse.json({ error: \"Team not found\" }, { status: 404 });\n      return NextResponse.json(csv, { status: 200, headers: { \"x-hotbat-source\": \"csv\" } });\n    }\n    return NextResponse.json(\n      { error: \"teamId must be a valid integer when HOTBAT_BACKEND=db\" },\n      { status: 400 },\n    );\n  }\n\n  const team = await prisma.team.findUnique({\n    where: { id: teamId },\n    select: {\n      id: true,\n      name: true,\n      abbrev: true,\n      league: true,\n      division: true,\n      logoUrl: true,\n    },\n  });\n  if (!team) {\n    return NextResponse.json({ error: \"Team not found\" }, { status: 404 });\n  }\n\n  const dateFilter =\n    fromDate || toDate\n      ? {\n          date: {\n            ...(fromDate ? { gte: fromDate } : {}),\n            ...(toDate ? { lte: toDate } : {}),\n          },\n        }\n      : {};\n\n  const stats = await prisma.teamGameHrStats.findMany({\n    where: {\n      teamId,\n      ...(season ? { season } : {}),\n      ...dateFilter,\n    },\n    orderBy: { date: \"asc\" },\n    include: {\n      opponentTeam: true,\n      game: {\n        include: { park: true },\n      },\n    },\n  });\n\n  const summaries = await prisma.teamHrSummary.findMany({\n    where: {\n      teamId,\n      ...(season ? { season } : {}),\n    },\n    orderBy: [{ season: \"desc\" }, { updatedAt: \"desc\" }],\n  });\n\n  const summary =\n    summaries.find((s) => s.splitKey === splitParam) ??\n    summaries.find((s) => s.splitKey === \"overall\");\n\n  const keyMetrics = summary\n    ? ([\n        {\n          id: \"hr_per_game\",\n          label: \"HR/Game\",\n          value: summary.hrPerGame.toFixed(2),\n        },\n        {\n          id: \"games_played\",\n          label: \"Games\",\n          value: summary.gamesPlayed.toString(),\n        },\n        {\n          id: \"total_hr\",\n          label: \"Total HR\",\n          value: summary.hr.toString(),\n        },\n        summary.hrVsLeaguePct !== null && summary.hrVsLeaguePct !== undefined\n          ? {\n              id: \"hr_vs_league_pct\",\n              label: \"HR vs League %\",\n              value: `${summary.hrVsLeaguePct.toFixed(1)}%`,\n            }\n          : undefined,\n        summary.avgEv !== null && summary.avgEv !== undefined\n          ? {\n              id: \"avg_ev\",\n              label: \"Avg EV\",\n              value: summary.avgEv.toFixed(1),\n            }\n          : undefined,\n      ] as const).filter(Boolean)\n    : [];\n\n  const hrTimeSeries = stats.map((s) => ({\n    date: s.date.toISOString(),\n    hr: s.hr,\n    xHr: s.xHr ?? undefined,\n    avgEv: s.avgEv ?? undefined,\n    barrels: s.barrels ?? undefined,\n  }));\n\n  const games = stats.map((s) => {\n    const game = s.game;\n    const teamScore =\n      game.homeTeamId === s.teamId ? game.homeScore : game.awayScore;\n    const opponentScore =\n      game.homeTeamId === s.teamId ? game.awayScore : game.homeScore;\n    const result =\n      teamScore !== null &&\n      opponentScore !== null &&\n      teamScore !== undefined &&\n      opponentScore !== undefined\n        ? `${teamScore > opponentScore ? \"W\" : \"L\"} ${teamScore}-${opponentScore}`\n        : undefined;\n    return {\n      id: game.id,\n      date: game.date.toISOString(),\n      opponent: s.opponentTeam?.name ?? \"Unknown\",\n      park: game.park.name,\n      result,\n      hr: s.hr,\n      xHr: s.xHr ?? undefined,\n      hrDiff:\n        s.xHr !== null && s.xHr !== undefined\n          ? Number((s.hr - s.xHr).toFixed(2))\n          : undefined,\n      opposingSp: undefined,\n      opposingSpHr9: undefined,\n    };\n  });\n\n  const splits = {\n    overview:\n      summaries\n        .filter((s) => s.splitKey === \"overall\")\n        .map((s) => ({\n          label: \"Overall HR/G\",\n          hrPerGame: s.hrPerGame,\n        })) ?? [],\n    homeAway: [],\n    lhpRhp: [],\n    monthly: [],\n  };\n\n  const upcoming = await prisma.game.findMany({\n    where: {\n      OR: [{ homeTeamId: teamId }, { awayTeamId: teamId }],\n      status: \"scheduled\",\n      ...(season ? { season } : {}),\n    },\n    orderBy: { date: \"asc\" },\n    include: {\n      homeTeam: true,\n      awayTeam: true,\n      park: {\n        include: {\n          parkHrFactors: {\n            where: season ? { season } : {},\n            orderBy: { updatedAt: \"desc\" },\n            take: 1,\n          },\n        },\n      },\n      gamePredictions: {\n        where: { teamId },\n        orderBy: { predictionTimestamp: \"desc\" },\n        take: 1,\n      },\n    },\n  });\n\n  const upcomingGames = upcoming.map((g) => {\n    const isHome = g.homeTeamId === teamId;\n    const opponent = isHome ? g.awayTeam : g.homeTeam;\n    const prediction = g.gamePredictions[0];\n    const parkFactor =\n      g.park.parkHrFactors[0]?.hrFactor ?? g.park.defaultHrFactor ?? undefined;\n    return {\n      gameId: g.id,\n      date: g.date.toISOString(),\n      opponentName: opponent.name,\n      opponentAbbrev: opponent.abbrev,\n      parkName: g.park.name,\n      parkHrFactor: parkFactor,\n      predictedHrMean: prediction?.predictedHrMean ?? undefined,\n      predictedHrStd: prediction?.predictedHrStd ?? undefined,\n      hotbatScore: prediction?.hotbatScore ?? undefined,\n    };\n  });\n\n  const response: TeamDashboardResponse = {\n    teamInfo: {\n      id: team.id,\n      name: team.name,\n      abbrev: team.abbrev,\n      league: team.league,\n      division: team.division,\n      logoUrl: logoPath(team.abbrev),\n    },\n    keyMetrics,\n    hrTimeSeries,\n    pitcherVulnerability: [],\n    upcomingGames,\n    splits,\n    games,\n  };\n\n  return NextResponse.json(response);\n}\n"],"names":[],"mappings":"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"}}]
}