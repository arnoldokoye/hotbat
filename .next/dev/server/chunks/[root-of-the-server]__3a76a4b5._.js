module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/@prisma/client [external] (@prisma/client, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("@prisma/client", () => require("@prisma/client"));

module.exports = mod;
}),
"[externals]/pg [external] (pg, esm_import)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

const mod = await __turbopack_context__.y("pg");

__turbopack_context__.n(mod);
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[project]/src/lib/prisma.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "prisma",
    ()=>prisma
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$prisma$2f$adapter$2d$pg$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@prisma/adapter-pg/dist/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__ = __turbopack_context__.i("[externals]/pg [external] (pg, esm_import)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$prisma$2f$adapter$2d$pg$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__,
    __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$prisma$2f$adapter$2d$pg$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__, __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
;
;
;
const connectionString = process.env.DATABASE_URL;
if (!connectionString) {
    throw new Error("DATABASE_URL is required to initialize Prisma");
}
// Ensure a single PrismaClient/Pool instance across hot reloads in dev.
const globalForPrisma = globalThis;
const defaultCaPath = process.env.NODE_EXTRA_CA_CERTS || __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), "prod-ca-2021.crt");
const caFileExists = ("TURBOPACK compile-time truthy", 1) ? __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(defaultCaPath) : "TURBOPACK unreachable";
const caBuffer = caFileExists ? __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(defaultCaPath) : undefined;
const allowInsecureEnv = process.env.DB_SSL_ALLOW_INSECURE === "1" || process.env.DB_SSL_ALLOW_INSECURE === "true" || process.env.NODE_TLS_REJECT_UNAUTHORIZED === "0";
const connectionTimeoutMs = Number.parseInt(process.env.DB_CONNECTION_TIMEOUT_MS ?? "", 10) || 5000;
const buildPool = (rejectUnauthorized)=>{
    const ssl = {
        rejectUnauthorized
    };
    if (caBuffer) {
        ssl.ca = caBuffer;
    }
    return {
        pool: new __TURBOPACK__imported__module__$5b$externals$5d2f$pg__$5b$external$5d$__$28$pg$2c$__esm_import$29$__["Pool"]({
            connectionString,
            ssl,
            connectionTimeoutMillis: connectionTimeoutMs
        }),
        usedInsecure: !rejectUnauthorized
    };
};
const isTlsError = (error)=>{
    if (!error || typeof error !== "object") return false;
    const code = error.code ?? "";
    const message = error.message ?? "";
    const tlsCodes = [
        "SELF_SIGNED_CERT_IN_CHAIN",
        "DEPTH_ZERO_SELF_SIGNED_CERT",
        "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
        "ERR_TLS_CERT_ALTNAME_INVALID",
        "UNABLE_TO_GET_ISSUER_CERT_LOCALLY"
    ];
    return tlsCodes.includes(code) || message.toLowerCase().includes("certificate");
};
const initPool = async ()=>{
    const primary = buildPool(!allowInsecureEnv);
    const warmupResult = await primary.pool.query("SELECT 1").then(()=>"ok").catch((error)=>{
        if (!allowInsecureEnv && isTlsError(error)) {
            return "tls-error";
        }
        console.warn("Database warm-up query failed; continuing with current SSL config.", error);
        return "failed";
    });
    if (warmupResult === "tls-error") {
        await primary.pool.end().catch(()=>{});
        console.warn("Database TLS verification failed; retrying with rejectUnauthorized=false. " + "Provide NODE_EXTRA_CA_CERTS with your trusted root to restore verification.");
        return buildPool(false);
    }
    return primary;
};
const { pool, usedInsecure } = globalForPrisma.pool && typeof globalForPrisma.__dbUsedInsecureSsl === "boolean" ? {
    pool: globalForPrisma.pool,
    usedInsecure: globalForPrisma.__dbUsedInsecureSsl
} : await initPool();
const adapter = globalForPrisma.adapter ?? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$prisma$2f$adapter$2d$pg$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PrismaPg"](pool);
const prisma = globalForPrisma.prisma ?? new __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["PrismaClient"]({
    adapter,
    log: ("TURBOPACK compile-time truthy", 1) ? [
        "warn",
        "error"
    ] : "TURBOPACK unreachable"
});
if ("TURBOPACK compile-time truthy", 1) {
    globalForPrisma.pool = pool;
    globalForPrisma.adapter = adapter;
    globalForPrisma.prisma = prisma;
    globalForPrisma.__dbUsedInsecureSsl = usedInsecure;
}
const __TURBOPACK__default__export__ = prisma;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[externals]/node:fs/promises [external] (node:fs/promises, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs/promises", () => require("node:fs/promises"));

module.exports = mod;
}),
"[externals]/node:path [external] (node:path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:path", () => require("node:path"));

module.exports = mod;
}),
"[project]/src/lib/csv/ballparks.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadBallparks",
    ()=>loadBallparks
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs/promises [external] (node:fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
;
;
const GAMELOGS_DIR = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(process.cwd(), "data_sources", "NEW_DATA_SETS", "2020-25 GAMELOGS");
const BALLPARKS_CSV_PATH = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(GAMELOGS_DIR, "ballparks.csv");
let cache = null;
function splitCsvLine(line) {
    const out = [];
    let cur = "";
    let inQuotes = false;
    for(let i = 0; i < line.length; i += 1){
        const ch = line[i];
        if (ch === '"') {
            if (inQuotes && line[i + 1] === '"') {
                cur += '"';
                i += 1;
                continue;
            }
            inQuotes = !inQuotes;
            continue;
        }
        if (ch === "," && !inQuotes) {
            out.push(cur);
            cur = "";
            continue;
        }
        cur += ch;
    }
    out.push(cur);
    return out;
}
async function loadBallparks() {
    const stat = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].stat(BALLPARKS_CSV_PATH);
    if (cache && cache.mtimeMs === stat.mtimeMs) return cache.byParkId;
    const csvText = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].readFile(BALLPARKS_CSV_PATH, "utf8");
    const text = csvText.replace(/^\uFEFF/, "").trim();
    const lines = text.split(/\r?\n/).filter(Boolean);
    if (lines.length < 2) throw new Error(`ballparks.csv is empty: ${BALLPARKS_CSV_PATH}`);
    const header = splitCsvLine(lines[0]).map((h)=>h.trim().toUpperCase());
    const idx = new Map(header.map((h, i)=>[
            h,
            i
        ]));
    function cell(cols, key) {
        const i = idx.get(key);
        return i === undefined ? "" : (cols[i] ?? "").trim();
    }
    const byParkId = new Map();
    for (const line of lines.slice(1)){
        const cols = splitCsvLine(line);
        const parkId = cell(cols, "PARKID");
        const name = cell(cols, "NAME");
        if (!parkId || !name) continue;
        if (!byParkId.has(parkId)) byParkId.set(parkId, name);
    }
    cache = {
        mtimeMs: stat.mtimeMs,
        byParkId
    };
    return byParkId;
}
}),
"[project]/src/lib/csv/csv.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseCsvText",
    ()=>parseCsvText,
    "readCsvFile",
    ()=>readCsvFile,
    "splitCsvLine",
    ()=>splitCsvLine
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs/promises [external] (node:fs/promises, cjs)");
;
function splitCsvLine(line) {
    const out = [];
    let cur = "";
    let inQuotes = false;
    for(let i = 0; i < line.length; i += 1){
        const ch = line[i];
        if (ch === '"') {
            if (inQuotes && line[i + 1] === '"') {
                cur += '"';
                i += 1;
                continue;
            }
            inQuotes = !inQuotes;
            continue;
        }
        if (ch === "," && !inQuotes) {
            out.push(cur);
            cur = "";
            continue;
        }
        cur += ch;
    }
    out.push(cur);
    return out;
}
function parseCsvText(text) {
    const stripped = text.replace(/^\uFEFF/, "").trim();
    if (!stripped) return {
        header: [],
        rows: []
    };
    const lines = stripped.split(/\r?\n/).filter(Boolean);
    if (lines.length === 0) return {
        header: [],
        rows: []
    };
    const header = splitCsvLine(lines[0]).map((h)=>h.trim());
    const rows = lines.slice(1).map((line)=>splitCsvLine(line).map((c)=>c.trim()));
    return {
        header,
        rows
    };
}
async function readCsvFile(filePath) {
    const stat = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].stat(filePath);
    const text = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].readFile(filePath, "utf8");
    const { header, rows } = parseCsvText(text);
    return {
        header,
        rows,
        mtimeMs: stat.mtimeMs
    };
}
}),
"[project]/src/lib/csv/dailyBatting.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadDailyBatting",
    ()=>loadDailyBatting
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$csv$2f$csv$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/csv/csv.ts [app-route] (ecmascript)");
;
;
const DAILY_LOGS_DIR = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(process.cwd(), "data_sources", "NEW_DATA_SETS", "2020-25 DAILY LOGS");
let cache = null;
function asInt(value) {
    const n = Number.parseInt(value, 10);
    return Number.isFinite(n) ? n : 0;
}
async function loadDailyBatting(season) {
    const filePath = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(DAILY_LOGS_DIR, `${season}DAILY_LOGScsvs`, `${season}batting.csv`);
    const { header, rows, mtimeMs } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$csv$2f$csv$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readCsvFile"])(filePath);
    if (cache && cache.season === season && cache.mtimeMs === mtimeMs) return cache.rows;
    const idx = new Map(header.map((h, i)=>[
            h,
            i
        ]));
    const cell = (cols, key)=>{
        const i = idx.get(key);
        return i === undefined ? "" : cols[i] ?? "";
    };
    const parsed = [];
    for (const cols of rows){
        const stattype = cell(cols, "stattype").toLowerCase();
        if (stattype && stattype !== "value") continue;
        const gid = cell(cols, "gid");
        const player_id = cell(cols, "id");
        const team = cell(cols, "team");
        const opp = cell(cols, "opp");
        const vishome = cell(cols, "vishome");
        const site = cell(cols, "site");
        const date = cell(cols, "date");
        if (!gid || !player_id || !team || !date) continue;
        parsed.push({
            gid,
            player_id,
            team,
            opp,
            vishome: vishome === "h" || vishome === "v" ? vishome : "",
            site,
            date,
            b_pa: asInt(cell(cols, "b_pa")),
            b_ab: asInt(cell(cols, "b_ab")),
            b_hr: asInt(cell(cols, "b_hr")),
            b_d: asInt(cell(cols, "b_d")),
            b_t: asInt(cell(cols, "b_t")),
            b_rbi: asInt(cell(cols, "b_rbi")),
            b_w: asInt(cell(cols, "b_w")),
            b_k: asInt(cell(cols, "b_k"))
        });
    }
    // Deterministic ordering.
    parsed.sort((a, b)=>{
        if (a.date !== b.date) return a.date.localeCompare(b.date);
        if (a.gid !== b.gid) return a.gid.localeCompare(b.gid);
        if (a.player_id !== b.player_id) return a.player_id.localeCompare(b.player_id);
        return a.team.localeCompare(b.team);
    });
    cache = {
        season,
        mtimeMs,
        rows: parsed
    };
    return parsed;
}
}),
"[project]/src/lib/csv/dailyPitching.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadDailyPitchingStartersByGame",
    ()=>loadDailyPitchingStartersByGame
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$csv$2f$csv$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/csv/csv.ts [app-route] (ecmascript)");
;
;
const DAILY_LOGS_DIR = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(process.cwd(), "data_sources", "NEW_DATA_SETS", "2020-25 DAILY LOGS");
let cache = null;
function asInt(value) {
    const n = Number.parseInt(value, 10);
    return Number.isFinite(n) ? n : 0;
}
async function loadDailyPitchingStartersByGame(season) {
    const filePath = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(DAILY_LOGS_DIR, `${season}DAILY_LOGScsvs`, `${season}pitching.csv`);
    const { header, rows, mtimeMs } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$csv$2f$csv$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["readCsvFile"])(filePath);
    if (cache && cache.season === season && cache.mtimeMs === mtimeMs) return cache.startersByGame;
    const idx = new Map(header.map((h, i)=>[
            h,
            i
        ]));
    const cell = (cols, key)=>{
        const i = idx.get(key);
        return i === undefined ? "" : cols[i] ?? "";
    };
    const startersByGame = new Map();
    for (const cols of rows){
        const stattype = cell(cols, "stattype").toLowerCase();
        if (stattype && stattype !== "value") continue;
        const pSeq = asInt(cell(cols, "p_seq"));
        if (pSeq !== 1) continue;
        const gid = cell(cols, "gid");
        const pitcher_id = cell(cols, "id");
        const vishome = cell(cols, "vishome");
        if (!gid || !pitcher_id) continue;
        const entry = startersByGame.get(gid) ?? {};
        if (vishome === "h") entry.home = pitcher_id;
        if (vishome === "v") entry.away = pitcher_id;
        startersByGame.set(gid, entry);
    }
    cache = {
        season,
        mtimeMs,
        startersByGame
    };
    return startersByGame;
}
}),
"[project]/src/lib/csv/playerRegistry.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadPlayerRegistry",
    ()=>loadPlayerRegistry
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs/promises [external] (node:fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
;
;
const PLAYER_REGISTRY_CSV_PATH = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(process.cwd(), "scripts", "ml", "data", "player_registry.csv");
const BIOFILE_CSV_PATH = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(process.cwd(), "data_sources", "NEW_DATA_SETS", "2020-25 GAMELOGS", "biofile (1)", "biofile.csv");
let cache = null;
function splitCsvLine(line) {
    const out = [];
    let cur = "";
    let inQuotes = false;
    for(let i = 0; i < line.length; i += 1){
        const ch = line[i];
        if (ch === '"') {
            if (inQuotes && line[i + 1] === '"') {
                cur += '"';
                i += 1;
                continue;
            }
            inQuotes = !inQuotes;
            continue;
        }
        if (ch === "," && !inQuotes) {
            out.push(cur);
            cur = "";
            continue;
        }
        cur += ch;
    }
    out.push(cur);
    return out;
}
function normalizeBats(value) {
    const v = value.trim().toUpperCase();
    if (v === "L" || v === "R" || v === "B") return v;
    return null;
}
function normalizeThrows(value) {
    const v = value.trim().toUpperCase();
    if (v === "L" || v === "R") return v;
    return null;
}
function parseYearFromMmDdYyyy(value) {
    const v = value.trim();
    const m = /^\d{2}\/\d{2}\/(\d{4})$/.exec(v);
    if (!m) return null;
    const year = Number.parseInt(m[1], 10);
    return Number.isFinite(year) ? year : null;
}
async function loadPlayerRegistryRows() {
    const csvText = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].readFile(PLAYER_REGISTRY_CSV_PATH, "utf8");
    const text = csvText.replace(/^\uFEFF/, "").trim();
    if (!text) return [];
    const lines = text.split(/\r?\n/).filter(Boolean);
    if (lines.length < 2) return [];
    const header = splitCsvLine(lines[0]).map((h)=>h.trim());
    const idx = new Map(header.map((h, i)=>[
            h,
            i
        ]));
    const idIdx = idx.get("player_id");
    const firstIdx = idx.get("first_name");
    const lastIdx = idx.get("last_name");
    const nameIdx = idx.get("full_name");
    if (idIdx === undefined || nameIdx === undefined || firstIdx === undefined || lastIdx === undefined) {
        return [];
    }
    const rows = [];
    for (const line of lines.slice(1)){
        const cols = splitCsvLine(line);
        const player_id = (cols[idIdx] ?? "").trim();
        const first_name = (cols[firstIdx] ?? "").trim();
        const last_name = (cols[lastIdx] ?? "").trim();
        const player_name = (cols[nameIdx] ?? "").trim();
        if (!player_id || !player_name || !first_name || !last_name) continue;
        rows.push({
            player_id,
            player_name,
            first_name,
            last_name
        });
    }
    return rows;
}
async function loadBioHands() {
    const byId = new Map();
    const csvText = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].readFile(BIOFILE_CSV_PATH, "utf8");
    const text = csvText.replace(/^\uFEFF/, "").trim();
    if (!text) return byId;
    const lines = text.split(/\r?\n/).filter(Boolean);
    if (lines.length < 2) return byId;
    const header = splitCsvLine(lines[0]).map((h)=>h.trim().toUpperCase());
    const idx = new Map(header.map((h, i)=>[
            h,
            i
        ]));
    function cell(cols, key) {
        const i = idx.get(key);
        return i === undefined ? "" : (cols[i] ?? "").trim();
    }
    for (const line of lines.slice(1)){
        const cols = splitCsvLine(line);
        const playerId = cell(cols, "PLAYERID");
        if (!playerId) continue;
        if (byId.has(playerId)) continue;
        const bats = normalizeBats(cell(cols, "BATS"));
        const throws = normalizeThrows(cell(cols, "THROWS"));
        const first_season = parseYearFromMmDdYyyy(cell(cols, "PLAY.DEBUT"));
        const last_season = parseYearFromMmDdYyyy(cell(cols, "PLAY.LASTGAME"));
        byId.set(playerId, {
            bats,
            throws,
            first_season,
            last_season
        });
    }
    return byId;
}
async function loadPlayerRegistry() {
    const registryStat = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].stat(PLAYER_REGISTRY_CSV_PATH);
    let bioStat = null;
    try {
        bioStat = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].stat(BIOFILE_CSV_PATH);
    } catch  {
        bioStat = null;
    }
    if (cache && cache.registryMtimeMs === registryStat.mtimeMs && cache.bioMtimeMs === (bioStat ? bioStat.mtimeMs : null)) {
        return cache.players;
    }
    const registryRows = await loadPlayerRegistryRows();
    if (!registryRows.length) {
        cache = {
            registryMtimeMs: registryStat.mtimeMs,
            bioMtimeMs: bioStat?.mtimeMs ?? null,
            players: []
        };
        return [];
    }
    const bioById = bioStat ? await loadBioHands() : new Map();
    const players = registryRows.map((r)=>{
        const bio = bioById.get(r.player_id);
        return {
            player_id: r.player_id,
            player_name: r.player_name,
            first_name: r.first_name,
            last_name: r.last_name,
            bats: bio?.bats ?? null,
            throws: bio?.throws ?? null,
            first_season: bio?.first_season ?? null,
            last_season: bio?.last_season ?? null
        };
    });
    // Deterministic ordering.
    players.sort((a, b)=>{
        if (a.player_name !== b.player_name) return a.player_name.localeCompare(b.player_name);
        return a.player_id.localeCompare(b.player_id);
    });
    cache = {
        registryMtimeMs: registryStat.mtimeMs,
        bioMtimeMs: bioStat?.mtimeMs ?? null,
        players
    };
    return players;
}
}),
"[project]/src/lib/csv/teams.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "loadTeams",
    ()=>loadTeams
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs/promises [external] (node:fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
;
;
const GAMELOGS_DIR = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(process.cwd(), "data_sources", "NEW_DATA_SETS", "2020-25 GAMELOGS");
const TEAMS_CSV_PATH = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(GAMELOGS_DIR, "teams.csv");
let cache = null;
function splitCsvLine(line) {
    const out = [];
    let cur = "";
    let inQuotes = false;
    for(let i = 0; i < line.length; i += 1){
        const ch = line[i];
        if (ch === '"') {
            if (inQuotes && line[i + 1] === '"') {
                cur += '"';
                i += 1;
                continue;
            }
            inQuotes = !inQuotes;
            continue;
        }
        if (ch === "," && !inQuotes) {
            out.push(cur);
            cur = "";
            continue;
        }
        cur += ch;
    }
    out.push(cur);
    return out;
}
function parseIntSafe(value) {
    const v = value.trim();
    if (!v) return null;
    const n = Number.parseInt(v, 10);
    return Number.isFinite(n) ? n : null;
}
async function loadTeams(options) {
    const stat = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].stat(TEAMS_CSV_PATH);
    if (cache && cache.mtimeMs === stat.mtimeMs) return cache.teams;
    const csvText = await __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs$2f$promises__$5b$external$5d$__$28$node$3a$fs$2f$promises$2c$__cjs$29$__["default"].readFile(TEAMS_CSV_PATH, "utf8");
    const text = csvText.replace(/^\uFEFF/, "").trim();
    if (!text) {
        cache = {
            mtimeMs: stat.mtimeMs,
            teams: []
        };
        return [];
    }
    const lines = text.split(/\r?\n/).filter(Boolean);
    if (lines.length < 2) {
        cache = {
            mtimeMs: stat.mtimeMs,
            teams: []
        };
        return [];
    }
    const header = splitCsvLine(lines[0]).map((h)=>h.trim().toUpperCase());
    const idx = new Map(header.map((h, i)=>[
            h,
            i
        ]));
    function cell(cols, key) {
        const i = idx.get(key);
        return i === undefined ? "" : (cols[i] ?? "").trim();
    }
    const minSeason = options?.minSeason ?? 2020;
    const maxSeason = options?.maxSeason ?? 2025;
    const leagues = options?.leagues?.map((l)=>l.trim().toUpperCase()).filter(Boolean) ?? [
        "AL",
        "NL"
    ];
    const bestByTeam = new Map();
    for (const line of lines.slice(1)){
        const cols = splitCsvLine(line);
        const team_id = cell(cols, "TEAM");
        const league = cell(cols, "LEAGUE").toUpperCase();
        const city = cell(cols, "CITY");
        const nickname = cell(cols, "NICKNAME");
        const first = parseIntSafe(cell(cols, "FIRST")) ?? 0;
        const last = parseIntSafe(cell(cols, "LAST")) ?? 9999;
        if (!team_id || !city || !nickname) continue;
        if (leagues.length && league && !leagues.includes(league)) continue;
        if (last < minSeason || first > maxSeason) continue;
        const name = `${city} ${nickname}`;
        const cand = {
            first,
            last,
            league: league || null,
            name
        };
        const existing = bestByTeam.get(team_id);
        if (!existing) {
            bestByTeam.set(team_id, cand);
            continue;
        }
        // Prefer the most recent era (highest FIRST), then lexicographic name for determinism.
        if (cand.first > existing.first) {
            bestByTeam.set(team_id, cand);
        } else if (cand.first === existing.first && cand.name < existing.name) {
            bestByTeam.set(team_id, cand);
        }
    }
    const teams = Array.from(bestByTeam.entries()).map(([team_id, cand])=>({
            team_id,
            team_name: cand.name,
            league: cand.league
        }));
    teams.sort((a, b)=>{
        if (a.team_name !== b.team_name) return a.team_name.localeCompare(b.team_name);
        return a.team_id.localeCompare(b.team_id);
    });
    cache = {
        mtimeMs: stat.mtimeMs,
        teams
    };
    return teams;
}
}),
"[project]/src/app/api/player-dashboard/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/prisma.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$csv$2f$ballparks$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/csv/ballparks.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$csv$2f$dailyBatting$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/csv/dailyBatting.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$csv$2f$dailyPitching$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/csv/dailyPitching.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$csv$2f$playerRegistry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/csv/playerRegistry.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$csv$2f$teams$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/csv/teams.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
;
;
;
;
;
const logoPath = (abbrev)=>{
    return abbrev ? `/team-logos/${abbrev.toLowerCase()}.svg` : "/team-logos/default.svg";
};
const logoFromRetrosheetTeam = (teamId)=>{
    const id = teamId.trim().toUpperCase();
    if (id === "NYA") return logoPath("nyy");
    if (id === "BOS") return logoPath("bos");
    return logoPath(null);
};
function yyyymmddToIsoDate(value) {
    const v = value.trim();
    if (!/^\d{8}$/.test(v)) return null;
    return `${v.slice(0, 4)}-${v.slice(4, 6)}-${v.slice(6, 8)}`;
}
function isoDateToTimestamp(value) {
    return `${value}T00:00:00.000Z`;
}
function hash32FNV1a(input) {
    let hash = 0x811c9dc5;
    for(let i = 0; i < input.length; i += 1){
        hash ^= input.charCodeAt(i);
        hash = Math.imul(hash, 0x01000193);
    }
    return hash >>> 0;
}
function safeDiv(numer, denom) {
    if (!Number.isFinite(numer) || !Number.isFinite(denom) || denom <= 0) return null;
    return numer / denom;
}
async function loadPlayerDashboardFromCsv(args) {
    const { playerId, season, splitKey: _splitKey } = args;
    void _splitKey;
    const [battingRows, startersByGame, players, teams, parks] = await Promise.all([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$csv$2f$dailyBatting$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["loadDailyBatting"])(season),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$csv$2f$dailyPitching$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["loadDailyPitchingStartersByGame"])(season),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$csv$2f$playerRegistry$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["loadPlayerRegistry"])(),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$csv$2f$teams$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["loadTeams"])().catch(()=>[]),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$csv$2f$ballparks$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["loadBallparks"])().catch(()=>new Map())
    ]);
    const playerById = new Map(players.map((p)=>[
            p.player_id,
            p
        ]));
    const teamNameById = new Map(teams.map((t)=>[
            t.team_id,
            t.team_name
        ]));
    const playerMeta = playerById.get(playerId);
    if (!playerMeta) return null;
    const playerBatting = battingRows.filter((r)=>r.player_id === playerId);
    const gameAggByGid = new Map();
    for (const row of playerBatting){
        const dateIso = yyyymmddToIsoDate(row.date);
        if (!dateIso) continue;
        const existing = gameAggByGid.get(row.gid);
        if (existing) {
            existing.pa += row.b_pa;
            existing.ab += row.b_ab;
            existing.hr += row.b_hr;
            existing.doubles += row.b_d;
            existing.triples += row.b_t;
            existing.rbi += row.b_rbi;
            existing.bb += row.b_w;
            existing.k += row.b_k;
            continue;
        }
        const starters = startersByGame.get(row.gid);
        const opposingStarterId = row.vishome === "h" ? starters?.away ?? null : row.vishome === "v" ? starters?.home ?? null : null;
        const opposingPitcher = opposingStarterId ? playerById.get(opposingStarterId) : undefined;
        const opposingStarterThrows = opposingPitcher?.throws === "L" || opposingPitcher?.throws === "R" ? opposingPitcher.throws : null;
        gameAggByGid.set(row.gid, {
            gid: row.gid,
            date: dateIso,
            team: row.team,
            opp: row.opp,
            vishome: row.vishome,
            site: row.site,
            pa: row.b_pa,
            ab: row.b_ab,
            hr: row.b_hr,
            doubles: row.b_d,
            triples: row.b_t,
            rbi: row.b_rbi,
            bb: row.b_w,
            k: row.b_k,
            opposingStarterId,
            opposingStarterThrows
        });
    }
    const games = Array.from(gameAggByGid.values());
    // Deterministic ordering.
    games.sort((a, b)=>{
        if (a.date !== b.date) return a.date.localeCompare(b.date);
        return a.gid.localeCompare(b.gid);
    });
    const latestGame = games.length ? games[games.length - 1] : null;
    const teamId = latestGame?.team ?? "";
    const teamName = teamNameById.get(teamId) ?? teamId;
    const firstName = playerMeta.first_name ?? playerMeta.player_name.split(" ")[0] ?? "";
    const lastName = playerMeta.last_name ?? playerMeta.player_name.split(" ").slice(1).join(" ") ?? "";
    const bats = playerMeta.bats ?? "R";
    const totals = games.reduce((acc, g)=>{
        acc.hr += g.hr;
        acc.pa += g.pa;
        acc.ab += g.ab;
        acc.doubles += g.doubles;
        acc.triples += g.triples;
        return acc;
    }, {
        hr: 0,
        pa: 0,
        ab: 0,
        doubles: 0,
        triples: 0
    });
    const hrPerPa = safeDiv(totals.hr, totals.pa);
    const iso = safeDiv(totals.doubles + 2 * totals.triples + 3 * totals.hr, totals.ab);
    const seasonHr = totals.hr;
    const seasonPa = totals.pa;
    const hrProb = safeDiv(seasonHr, seasonPa) ?? 0;
    const projectedPa = 4.0;
    const expectedHr = hrProb * projectedPa;
    const computeSplit = (filter)=>{
        const subset = games.filter(filter);
        const sum = subset.reduce((acc, g)=>{
            acc.hr += g.hr;
            acc.pa += g.pa;
            acc.ab += g.ab;
            acc.doubles += g.doubles;
            acc.triples += g.triples;
            return acc;
        }, {
            hr: 0,
            pa: 0,
            ab: 0,
            doubles: 0,
            triples: 0
        });
        const gamesPlayed = subset.length;
        return {
            season,
            gamesPlayed,
            hr: sum.hr,
            xHr: null,
            hrPerPa: safeDiv(sum.hr, sum.pa),
            barrelRate: null,
            avgEv: null,
            iso: safeDiv(sum.doubles + 2 * sum.triples + 3 * sum.hr, sum.ab),
            hardHitRate: null
        };
    };
    const splits = {
        overall: computeSplit(()=>true),
        home: computeSplit((g)=>g.vishome === "h"),
        away: computeSplit((g)=>g.vishome === "v"),
        lhp: computeSplit((g)=>g.opposingStarterThrows === "L"),
        rhp: computeSplit((g)=>g.opposingStarterThrows === "R")
    };
    // Monthly splits (YYYY-MM).
    for (const g of games){
        const monthKey = `month:${g.date.slice(0, 7)}`;
        if (!splits[monthKey]) {
            splits[monthKey] = computeSplit((x)=>x.date.slice(0, 7) === g.date.slice(0, 7));
        }
    }
    const keyMetrics = [
        {
            label: "HR",
            value: seasonHr
        },
        {
            label: "xHR",
            value: null
        },
        {
            label: "HR/PA",
            value: hrPerPa
        },
        {
            label: "Barrel%",
            value: null
        },
        {
            label: "Avg EV",
            value: null
        },
        {
            label: "ISO",
            value: iso
        },
        {
            label: "HardHit%",
            value: null
        }
    ];
    const gamesDesc = [
        ...games
    ].sort((a, b)=>{
        if (a.date !== b.date) return b.date.localeCompare(a.date);
        return b.gid.localeCompare(a.gid);
    });
    const latest10 = gamesDesc.slice(0, 10);
    const hrTimeSeries = [
        ...latest10
    ].reverse().map((g)=>({
            date: isoDateToTimestamp(g.date),
            gameId: hash32FNV1a(g.gid),
            hr: g.hr,
            xHr: null,
            avgEv: null,
            opponent: teamNameById.get(g.opp) ?? g.opp ?? "Opponent",
            park: parks.get(g.site) ?? g.site ?? "Park"
        }));
    const recentGames = gamesDesc.slice(0, 5).map((g)=>({
            gameId: hash32FNV1a(g.gid),
            date: isoDateToTimestamp(g.date),
            opponent: teamNameById.get(g.opp) ?? g.opp ?? "Opponent",
            park: parks.get(g.site) ?? g.site ?? "Park",
            hr: g.hr,
            xHr: null,
            avgEv: null
        }));
    const parkAgg = games.reduce((acc, g)=>{
        const parkName = parks.get(g.site) ?? g.site ?? "Unknown Park";
        acc[parkName] ??= {
            hr: 0,
            pa: 0
        };
        acc[parkName].hr += g.hr;
        acc[parkName].pa += g.pa;
        return acc;
    }, {});
    const parkProfile = Object.entries(parkAgg).map(([parkName, agg])=>({
            parkName,
            hrAtPark: agg.hr,
            hrPerPaAtPark: agg.pa > 0 ? agg.hr / agg.pa : 0,
            parkHrFactor: null
        }));
    return {
        playerInfo: {
            id: 0,
            firstName,
            lastName,
            bats,
            position: "—",
            team: {
                id: 0,
                name: teamName,
                abbrev: teamId,
                league: "",
                division: "",
                logoUrl: logoFromRetrosheetTeam(teamId)
            }
        },
        keyMetrics,
        splits,
        hrTimeSeries,
        recentGames,
        upcomingGames: [],
        parkProfile,
        baseline: {
            hrProb,
            expectedHr,
            seasonHr,
            seasonPa,
            notes: "Baseline: HR probability = season HR / season PA; Expected HR = HR probability × 4.0 PA window (deterministic)."
        }
    };
}
async function GET(req) {
    try {
        const { searchParams } = req.nextUrl;
        const playerIdParam = searchParams.get("playerId");
        const playerIdAlt = searchParams.get("player_id");
        const seasonParam = searchParams.get("season");
        const splitParam = searchParams.get("split") ?? "overall";
        const season = seasonParam ? Number(seasonParam) : 2024;
        const seasonValue = Number.isNaN(season) ? 2024 : season;
        const mode = (process.env.HOTBAT_BACKEND ?? "auto").toLowerCase();
        const rawPlayerId = (playerIdAlt ?? playerIdParam ?? "").trim();
        if (!rawPlayerId) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "playerId query param is required"
            }, {
                status: 400
            });
        }
        if (mode === "csv" || playerIdAlt && mode !== "db") {
            const csv = await loadPlayerDashboardFromCsv({
                playerId: rawPlayerId,
                season: seasonValue,
                splitKey: splitParam
            });
            if (!csv) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: "Player not found"
                }, {
                    status: 404
                });
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(csv, {
                status: 200,
                headers: {
                    "x-hotbat-source": "csv"
                }
            });
        }
        const playerId = Number(rawPlayerId);
        if (Number.isNaN(playerId)) {
            if (mode === "auto") {
                const csv = await loadPlayerDashboardFromCsv({
                    playerId: rawPlayerId,
                    season: seasonValue,
                    splitKey: splitParam
                });
                if (!csv) {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        error: "Player not found"
                    }, {
                        status: 404
                    });
                }
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(csv, {
                    status: 200,
                    headers: {
                        "x-hotbat-source": "csv"
                    }
                });
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "playerId must be a valid integer when HOTBAT_BACKEND=db"
            }, {
                status: 400
            });
        }
        const player = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].player.findUnique({
            where: {
                id: playerId
            },
            include: {
                team: true
            }
        });
        if (!player) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Player not found"
            }, {
                status: 404
            });
        }
        const summary = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].playerHrSummary.findFirst({
            where: {
                playerId,
                season: seasonValue,
                splitKey: splitParam
            },
            orderBy: {
                updatedAt: "desc"
            }
        });
        const summaries = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].playerHrSummary.findMany({
            where: {
                playerId,
                season: seasonValue
            }
        });
        const stats = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].playerGameStats.findMany({
            where: {
                playerId,
                season: seasonValue
            },
            orderBy: {
                date: "desc"
            },
            include: {
                game: {
                    include: {
                        homeTeam: true,
                        awayTeam: true,
                        park: true
                    }
                }
            },
            take: 10
        });
        const hrTimeSeries = [
            ...stats
        ].reverse().map((s)=>({
                date: s.date.toISOString(),
                gameId: s.gameId,
                hr: s.hr,
                xHr: s.xHr ?? null,
                avgEv: s.avgEv ?? null,
                opponent: s.game.homeTeamId === s.teamId ? s.game.awayTeam?.name ?? "Opponent" : s.game.homeTeam?.name ?? "Opponent",
                park: s.game.park.name
            }));
        const recentGames = stats.slice(0, 5).map((s)=>({
                gameId: s.gameId,
                date: s.date.toISOString(),
                opponent: s.game.homeTeamId === s.teamId ? s.game.awayTeam?.name ?? "Opponent" : s.game.homeTeam?.name ?? "Opponent",
                park: s.game.park.name,
                hr: s.hr,
                xHr: s.xHr ?? null,
                avgEv: s.avgEv ?? null
            }));
        const keyMetrics = [
            {
                label: "HR",
                value: summary?.hr ?? 0
            },
            {
                label: "xHR",
                value: summary?.xHr ?? null
            },
            {
                label: "HR/PA",
                value: summary?.hrPerPa ?? null
            },
            {
                label: "Barrel%",
                value: summary?.barrelRate ?? null
            },
            {
                label: "Avg EV",
                value: summary?.avgEv ?? null
            },
            {
                label: "ISO",
                value: summary?.iso ?? null
            },
            {
                label: "HardHit%",
                value: summary?.hardHitRate ?? null
            }
        ];
        const splits = {};
        const targetSummaries = summaries.length > 0 ? summaries : summary ? [
            summary
        ] : [];
        for (const s of targetSummaries){
            splits[s.splitKey] = {
                season: s.season,
                gamesPlayed: s.gamesPlayed,
                hr: s.hr,
                xHr: s.xHr ?? null,
                hrPerPa: s.hrPerPa ?? null,
                barrelRate: s.barrelRate ?? null,
                avgEv: s.avgEv ?? null,
                iso: s.iso ?? null,
                hardHitRate: s.hardHitRate ?? null
            };
        }
        if (Object.keys(splits).length === 0) {
            splits[splitParam] = {
                season: seasonValue,
                gamesPlayed: 0,
                hr: 0,
                xHr: null,
                hrPerPa: null,
                barrelRate: null,
                avgEv: null,
                iso: null,
                hardHitRate: null
            };
        }
        const parkAgg = stats.reduce((acc, stat)=>{
            const parkName = stat.game.park.name ?? "Unknown Park";
            const hr = stat.hr ?? 0;
            const pa = stat.pa ?? 0;
            const factor = stat.game.park.defaultHrFactor ?? null;
            const current = acc[parkName] ?? {
                hr: 0,
                pa: 0,
                factor
            };
            acc[parkName] = {
                hr: current.hr + hr,
                pa: current.pa + pa,
                factor: current.factor ?? factor
            };
            return acc;
        }, {});
        const parkProfile = Object.entries(parkAgg).map(([parkName, agg])=>({
                parkName,
                hrAtPark: agg.hr,
                hrPerPaAtPark: agg.pa > 0 ? agg.hr / agg.pa : 0,
                parkHrFactor: agg.factor
            }));
        const seasonHr = summary?.hr ?? 0;
        const seasonPa = summary?.pa ?? 0;
        const hrProb = seasonPa > 0 ? seasonHr / seasonPa : 0;
        const projectedPa = 4.0; // deterministic baseline window
        const expectedHr = hrProb * projectedPa;
        const response = {
            playerInfo: {
                id: player.id,
                firstName: player.firstName,
                lastName: player.lastName,
                bats: player.bats,
                position: player.position,
                team: {
                    id: player.team.id,
                    name: player.team.name,
                    abbrev: player.team.abbrev,
                    league: player.team.league,
                    division: player.team.division,
                    logoUrl: logoPath(player.team.abbrev)
                }
            },
            keyMetrics,
            splits,
            hrTimeSeries,
            recentGames,
            parkProfile,
            upcomingGames: [],
            baseline: {
                hrProb,
                expectedHr,
                seasonHr,
                seasonPa,
                notes: "Baseline: HR probability = season HR / season PA; Expected HR = HR probability × 4.0 PA window (deterministic)."
            }
        };
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(response);
    } catch (error) {
        console.error("Error in /api/player-dashboard", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: "Internal server error"
        }, {
            status: 500
        });
    }
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__3a76a4b5._.js.map